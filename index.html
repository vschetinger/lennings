<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Lennings</title>
<meta property="article:author" content="Alexander Mordvintsev">
<meta property="article:author" content="Eyvind Niklasson">

<!--  https://dev.twitter.com/cards/types/summary -->
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lennings">
<meta name="twitter:description" content="Interactive particle-based artificial life simulation">
<meta name="twitter:url" content="https://vschetinger.github.io/lennings/">
<meta name="twitter:image" content="lenia_card.jpg">
<meta name="twitter:image:width" content="600">
<meta name="twitter:image:height" content="600">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NXJWS6Y0G1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){{dataLayer.push(arguments);}}
  gtag('js', new Date());
  gtag('config', 'G-NXJWS6Y0G1');
</script>

<script src="twgl.min.js"> </script>
<script src="dat.gui.min.js"> </script>
<script src="zoo.js"> </script>
<script src="serialize.js"> </script>
<script src="PNGView.js"> </script>
    <script src="lenia.js?v=33"></script>
<script src="audiosys.js"> </script>
<script src="names.js"> </script>
<script src="webm-writer2.js"> </script>
<script src="videowriter.js"> </script>
<!-- <script src="anims.js"> </script> -->

<style>
    /* input {width:300px} */
    label {display:inline-block; width:80px}
    body { 
        scroll-snap-type: y mandatory;
        font-family:Verdana, Geneva, Tahoma, sans-serif; 
        margin: 0; 
        padding: 0;
        overflow: hidden;
        user-select: none; -webkit-touch-callout: none; -webkit-user-select:none;
        background: #111;
    }

    .preview {
        width: 128px;
/*        padding: 2px;*/
/*        border: 5px blue;*/
/*        border: 10px blue;*/
    }
    #c {
        scroll-snap-align: start;
        width: 100vw; 
        height: 100vh; 
        display: block;
        touch-action: none; user-select: none; -webkit-touch-callout: none; -webkit-user-select:none;
    }
    .previewContainer { 
        scroll-snap-align: start;
        display: inline-block; position: relative; 
/*        border: 10px blue;*/

    }
    .previewOverlay {
      position: absolute;
      color: white;
      bottom: 7px;
      left: 5px;
      width: auto;
      height: auto;
      z-index: 1;
      font-size: 11px;
      cursor: pointer;
    }

    h1, p {margin: 0; display: none;}
    a:link {font-size: larger; text-decoration: none; }

    #container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        touch-action: none; user-select: none; -webkit-touch-callout: none; -webkit-user-select:none;
    }
    
    #stat {
        display: none;
    }

    .canvasOverlay {
        height: 100%;
        width: 100%;
        text-align: center;
        vertical-align: middle;
        position: absolute;
        z-index: 1;
        top: 0;
        left: 0;
        pointer-events: none;
        opacity: 0.0;
        background-color: rgb(0,0,0);
        background-color: rgba(0,0,0, 0.5);
        overflow-x: hidden;
        transition: opacity 1s 0.5s;
        color: white;
        font-size: 35px;
/*        animation-delay: 1s;*/
/*        display: none;*/
    }

    .canvasOverlay img {
        height: 50%;
        max-width: 100%;
    }

    #touch {
/*        display: block;*/
        opacity: 0.0;
        pointer-events: none;
    }

    .dbimg {
        max-width: 50%!important;
    }

    h1 {
        text-align: center;
    }

    details {
        margin: 10px; 
    }

    #zoo {
        display: none; /* Hidden for now - will be a popup later */
        scroll-snap-align: end;
        width: 90%;
        height: 320px;
        margin: 0 auto;
        overflow: scroll;
        text-align: center;
        scroll-snap-type: y mandatory;
    }


    #title{
        scroll-snap-align: start;
    }

    /* Mobile Controls Overlay */
    .mobile-controls-toggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 56px;
        height: 56px;
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        color: white;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 1000;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        transition: all 0.3s ease;
    }

    .mobile-controls-toggle:active {
        transform: scale(0.95);
        background: rgba(0, 0, 0, 0.9);
    }

    .mobile-controls-overlay {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(10px);
        padding: 20px;
        z-index: 999;
        transform: translateY(100%);
        transition: transform 0.3s ease;
        border-top: 2px solid rgba(255, 255, 255, 0.2);
        display: flex;
        flex-direction: column;
    }

    .mobile-controls-overlay.visible {
        transform: translateY(0);
    }

    .mobile-controls-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
        gap: 12px;
        max-width: 600px;
        margin: 0 auto;
        width: 100%;
        min-height: 60px;
    }

    .mobile-control-button {
        min-width: 60px;
        min-height: 60px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: white;
        font-size: 20px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        transition: all 0.2s ease;
        touch-action: manipulation;
    }

    .mobile-control-button:active {
        transform: scale(0.95);
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.4);
    }

    .mobile-control-button.active {
        background: rgba(74, 242, 161, 0.3);
        border-color: rgba(74, 242, 161, 0.6);
    }

    /* Hamburger menu is always visible on all devices */

    #uploadButton{
        background-color: #15163f;
        width: 128px;
        height: 128px;
        text-align: center;
        line-height: 115px;
        font-size: 100px;
        color: aliceblue;
        vertical-align: top;
    }

    /* Left-side Life Cycle panel */
    .life-panel {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        z-index: 1000;
    }
    
    .life-panel .dg.main {
        background: rgba(0, 20, 40, 0.9) !important;
    }
    
    .life-panel .dg .cr {
        background: rgba(0, 30, 60, 0.7) !important;
    }
    
    .life-panel .dg .title {
        background: #2a5a8a !important;
        color: #fff !important;
    }
    
    .life-panel .dg .property-name {
        color: #ccc !important;
    }

    /* Help overlay (mobile-friendly) */
    .help-overlay-btn {
        position: fixed;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 2rem;
        height: 2rem;
        padding: 0;
        border-radius: 0 6px 6px 0;
        font-size: 1rem;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0,0,0,0.5);
        color: #fff;
        border: 2px solid rgba(255,255,255,0.3);
        border-left: none;
        cursor: pointer;
        z-index: 1002;
        font-weight: 700;
    }
    .help-overlay-btn:hover { background: #6af; color: #000; }
    #helpOverlay {
        position: fixed;
        inset: 0;
        z-index: 1003;
        background: rgba(0,0,0,0.92);
        color: #e0e0e0;
        overflow: auto;
        padding: 1rem;
        box-sizing: border-box;
        -webkit-overflow-scrolling: touch;
    }
    #helpOverlay:not(.visible) { display: none; }
    #helpOverlay.visible { display: block; }
    #helpOverlay .help-content {
        max-width: 36rem;
        margin: 0 auto;
        padding: 1.5rem 1rem 2rem;
        max-height: calc(100vh - 2rem);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }
    #helpOverlay h2 { font-size: 1.1rem; margin: 1.5rem 0 0.5rem; color: #6af; }
    #helpOverlay h2:first-child { margin-top: 0; }
    #helpOverlay .help-section { margin-bottom: 1.25rem; }
    #helpOverlay .help-section p { display: block; margin: 0.5rem 0 0; font-size: 0.95rem; line-height: 1.6; color: #ccc; }
    #helpOverlay ul { margin: 0.5rem 0 0; padding-left: 1.25rem; font-size: 0.95rem; line-height: 1.5; color: #ccc; }
    #helpOverlay .help-keys { width: 100%; border-collapse: collapse; margin: 0.75rem 0 0; font-size: 0.9rem; }
    #helpOverlay .help-keys th, #helpOverlay .help-keys td { text-align: left; padding: 0.35rem 0.5rem; border-bottom: 1px solid #333; color: #ccc; }
    #helpOverlay .help-keys th { color: #888; font-weight: 500; }
    #helpOverlay .help-keys .key-cap { display: inline-block; min-width: 1.6em; padding: 0.15rem 0.4rem; background: #333; border-radius: 4px; font-family: monospace; text-align: center; }
    #helpOverlay .help-close { display: block; margin: 1.5rem 0 0; padding: 0.5rem 1rem; background: #6af; color: #000; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 1rem; }
    #helpOverlay .help-close:hover { opacity: 0.9; }


</style>

<!-- Header and instructions hidden for cleaner view -->

<div id="container">
<div class="canvasOverlay" id="touch"><img src="touch.svg"></img><br>touch / click and drag to pan</div>
<div class="canvasOverlay" id="herd"><img src="herd.svg"></img><br><b>long</b> touch / click to herd particles</div>
<div class="canvasOverlay" id="doubleclick"><img src="doubleclick.svg"></img><br><b>double</b> touch / click and <b>hold</b> to spawn new particles</div>
<div class="canvasOverlay" id="mouse"><img class="dbimg" src="mouse.svg"></img><img class="dbimg" src="pinch.svg"></img><br><b>scroll</b> or <b>pinch</b> to zoom</div>
<div class="canvasOverlay" id="space"><img src="space.svg"></img><br><b>space-bar</b>: play / pause</div>
<canvas id="c" width="800" height="800"></canvas>
<br>
</div>
<div id="zoo"></div>
<pre id="stat"></pre>
<div id="fps" style="position:fixed; bottom:10px; left:10px; color:#666; font-family:monospace; font-size:12px; z-index:1000; background:rgba(0,0,0,0.5); padding:4px 8px; border-radius:4px;"></div>
<a href="simulation/" style="position:fixed; bottom:10px; right:10px; color:#6af; font-size:12px; z-index:1000; background:rgba(0,0,0,0.5); padding:4px 8px; border-radius:4px; text-decoration:none; display:none;">Simulation</a>
<button type="button" class="help-overlay-btn" id="helpOverlayBtn" title="Show help" aria-label="Show help">?</button>
<div id="helpOverlay" role="dialog" aria-label="Help" aria-modal="true">
    <div class="help-content">
        <section class="help-section">
            <h2>What is Lenia?</h2>
            <p>Lenia is a particle-based artificial life system in continuous 2D space. Each agent has a position and state and interacts with others through a kernel that sums the influence of nearby particles to drive growth and movement. Unlike grid-based cellular automata, particles move freely in a continuous circular world.</p>
        </section>
        <section class="help-section">
            <h2>What are these agents?</h2>
            <p>These particles feed on the image you load (the ‚Äúresource‚Äù): they consume pixels, gain energy, and can reproduce or die. Over time they ‚Äúpaint‚Äù by eating the image. You can optionally add a depth map so movement is constrained by depth‚Äîin gradient mode they flow along depth contours; in connectivity mode, particles on the same depth layer interact more.</p>
        </section>
        <section class="help-section">
            <h2>Pan and zoom</h2>
            <p>Touch or click and drag to pan the view. Use scroll or pinch to zoom in and out. Double-click (or double-tap and hold) to set the spawn point where new particles appear.</p>
        </section>
        <section class="help-section">
            <h2>Keys and controls</h2>
            <p>Use the keys below on keyboard, or open the hamburger menu on mobile for the same actions.</p>
            <table class="help-keys" id="helpKeysTable"><thead><tr><th>Key</th><th>Action</th></tr></thead><tbody id="helpKeysBody"></tbody></table>
        </section>
        <button type="button" class="help-close" id="helpOverlayClose">Close</button>
    </div>
</div>
<canvas id="cellGraph" style="position:fixed; left:0; bottom:0; width:100vw; height:80px; z-index:1001; display:none; pointer-events:none;"></canvas>

<script>

const $ = s=>document.querySelector(s);
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl2', {alpha:false});
gl.getExtension("EXT_color_buffer_float");
gl.getExtension("OES_texture_float_linear");

const gui = new dat.GUI();
gui.close();
const fps = 60.0;

// Load parameters.json and initialize application
async function loadParameters() {
    try {
        const response = await fetch('parameters.json');
        const config = await response.json();
        
        // Build flat paramMap for easy lookup
        const paramMap = {};
        for (const [category, catData] of Object.entries(config)) {
            if (category === 'description' || category === 'version') continue;
            if (catData.params) {
                for (const [paramName, paramData] of Object.entries(catData.params)) {
                    paramMap[paramName] = paramData;
                }
            }
        }
        
        return { config, paramMap };
    } catch (error) {
        console.warn('Failed to load parameters.json, using defaults:', error);
        return { config: {}, paramMap: {} };
    }
}

// Helper to get parameter value from JSON with fallback
function getParamValue(paramMap, paramName, defaultValue) {
    const param = paramMap[paramName];
    if (param && param.value !== undefined) {
        return param.value;
    }
    return defaultValue;
}

// Helper to get parameter range/step info
function getParamRange(paramMap, paramName) {
    const param = paramMap[paramName];
    if (param && param.min !== undefined && param.max !== undefined && param.step !== undefined) {
        return { min: param.min, max: param.max, step: param.step, name: param.name || paramName };
    }
    return null;
}

// largely inspired by approch from https://blog.shovonhasan.com/using-promises-with-filereader/
const asyncReadAsDataURL = (inputFile) => {
  const fr = new FileReader();
  return new Promise((resolve, reject) => {
    fr.onerror = () => {
      fr.abort();
      reject(new DOMException("can't read dropped/pasted file"));
    };

    fr.onload = () => {
      resolve(fr.result);
    };

    fr.readAsDataURL(inputFile);
  });
};

// Mobile Controls System
class MobileControls {
    constructor() {
        this.isMobile = this.detectMobile();
        this.overlay = null;
        this.toggleButton = null;
        this.controls = [];
        this.visible = false;
        
        // Always create overlay - hamburger menu is always visible
        this.createOverlay();
    }
    
    detectMobile() {
        // Check for touch device and small screen
        const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isSmallScreen = window.matchMedia('(max-width: 768px)').matches;
        const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
        return (hasTouch && (isSmallScreen || isCoarsePointer));
    }
    
    createOverlay() {
        // Create toggle button (always visible)
        this.toggleButton = document.createElement('div');
        this.toggleButton.className = 'mobile-controls-toggle';
        this.toggleButton.textContent = '‚ò∞';
        this.toggleButton.addEventListener('click', () => this.toggle());
        document.body.appendChild(this.toggleButton);
        
        // Create overlay
        this.overlay = document.createElement('div');
        this.overlay.className = 'mobile-controls-overlay';
        
        const grid = document.createElement('div');
        grid.className = 'mobile-controls-grid';
        this.overlay.appendChild(grid);
        
        document.body.appendChild(this.overlay);
    }
    
    registerControl(config) {
        if (!this.overlay) return; // Overlay must exist
        
        this.controls.push(config);
        this.renderControls();
    }
    
    renderControls() {
        if (!this.overlay) {
            console.warn('MobileControls: overlay not created');
            return;
        }
        
        const grid = this.overlay.querySelector('.mobile-controls-grid');
        if (!grid) {
            console.warn('MobileControls: grid element not found');
            return;
        }
        
        grid.innerHTML = '';
        
        if (this.controls.length === 0) {
            console.warn('MobileControls: no controls registered');
            return;
        }
        
        this.controls.forEach((control, index) => {
            const button = document.createElement('div');
            button.className = 'mobile-control-button';
            button.textContent = control.key === ' ' ? '‚ê£' : control.key.toUpperCase();
            button.title = control.label || control.key;
            
            // Store control reference for state updates
            control.buttonElement = button;
            
            button.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (control.action) {
                    control.action();
                }
                // Update active state for toggle buttons based on actual state
                if (control.isToggle) {
                    if (control.key === 'q') {
                        button.classList.toggle('active', params.showCellGraph);
                    } else if (control.key === ' ') {
                        button.classList.toggle('active', params.paused);
                    } else {
                        button.classList.toggle('active');
                    }
                }
            });
            
            grid.appendChild(button);
        });
        
        console.log(`MobileControls: rendered ${this.controls.length} buttons`);
    }
    
    updateButtonState(controlKey, isActive) {
        const control = this.controls.find(c => c.key === controlKey);
        if (control && control.buttonElement) {
            if (isActive) {
                control.buttonElement.classList.add('active');
            } else {
                control.buttonElement.classList.remove('active');
            }
        }
    }
    
    toggle() {
        if (!this.overlay) return;
        this.visible = !this.visible;
        this.overlay.classList.toggle('visible', this.visible);
    }
    
    show() {
        if (!this.overlay) return;
        this.visible = true;
        this.overlay.classList.add('visible');
    }
    
    hide() {
        if (!this.overlay) return;
        this.visible = false;
        this.overlay.classList.remove('visible');
    }
}

// Initialize application with parameters from JSON
(async function init() {
    const { config, paramMap } = await loadParameters();
    
    // Initialize params object from JSON (with fallbacks for internal state)
    const params = {
        // Simulation parameters
        stepN: getParamValue(paramMap, 'stepN', 1),
        targetFPS: getParamValue(paramMap, 'targetFPS', 60),
        renderMode: getParamValue(paramMap, 'renderMode', 1),
        showCellGraph: getParamValue(paramMap, 'showCellGraph', false),
        showTrailsOverlay: getParamValue(paramMap, 'showTrailsOverlay', true),
        
        // Spawn controls
        spawnCount: getParamValue(paramMap, 'spawnCount', 512),
        spawnCenter: getParamValue(paramMap, 'spawnCenter', [0.0, 0.0]),
        
        // View state - always start focused on spawn center
        viewCenter: (() => {
            const spawn = getParamValue(paramMap, 'spawnCenter', [0.0, 0.0]);
            // Always use spawnCenter as initial view center (user can pan away after)
            return spawn.slice(); // Make a copy
        })(),
        viewExtent: getParamValue(paramMap, 'viewExtent', 50.0),
        mousePos: [-10000.0, 0.0],
        mouseDown: false,
        touchRadius: getParamValue(paramMap, 'touchRadius', 0.05),
        paused: false,
        shiftKey: false,
        pointAddI: 0,
        oscillogram: getParamValue(paramMap, 'oscillogram', false),

        'benchmark': bench,
        'fullscreen': fullscreen,
        'init circle': ()=>lenia.reset(params.spawnCount, params.spawnCenter),
        'toggle sound': ()=>audioSystem.toggle(),
    };

    // Initialize lenia with paramMap
    const lenia = new ParticleLenia(gl, gui, paramMap);
    const audioSystem = new AudioSystem(gl, fps);
    
    // Expose globally for event handlers
    window.params = params;
    window.lenia = lenia;
    window.audioSystem = audioSystem;

    // ======== LEFT-SIDE LIFE CYCLE PANEL ========
    // Create lifeGui BEFORE using it in dynamic GUI creation
    const lifeGui = new dat.GUI({ autoPlace: false });
    lifeGui.domElement.classList.add('life-panel');
    document.body.appendChild(lifeGui.domElement);

    // Dynamic GUI creation based on parameters.json
    // Create GUI folders and sliders for main GUI
    for (const [category, catData] of Object.entries(config)) {
        if (category === 'description' || category === 'version') continue;
        if (!catData.params || catData.gui !== 'main') continue;
        // Depth map has its own manual folder below (load/clear + sliders); skip here to avoid duplicate folder
        if (category === 'depth') continue;
        
        const folderName = catData.folder || category;
        const folder = gui.addFolder(folderName);
        
        for (const [paramName, paramData] of Object.entries(catData.params)) {
            if (paramData.value === undefined) continue;
            
            // Boolean parameters (checkboxes)
            if (typeof paramData.value === 'boolean') {
                params[paramName] = paramData.value;
                folder.add(params, paramName).name(paramData.name || paramName);
            }
            // Parameters with min/max/step (sliders)
            else if (paramData.min !== undefined && paramData.max !== undefined && paramData.step !== undefined) {
                // List of main GUI parameters that are uniforms (need to sync to lenia.U)
                const mainUniforms = ['dt', 'repulsion', 'm1', 's1', 'm2', 's2', 'fieldScale', 'fieldGE', 
                    'baseFreq', 'clockExp', 'audioVolume', 'pointsAlpha'];
                
                // If this is a uniform, control lenia.U directly
                if (mainUniforms.includes(paramName)) {
                    lenia.U[paramName] = paramData.value;  // Initialize uniform from JSON
                    params[paramName] = paramData.value;  // Also store in params for consistency
                    // Create slider that directly controls lenia.U (the uniform)
                    const slider = folder.add(lenia.U, paramName, paramData.min, paramData.max, paramData.step);
                    slider.name(paramData.name || paramName);
                    // Also keep params in sync for consistency
                    slider.onChange((value) => {
                        params[paramName] = value;
                        // Handle callbacks
                        if (paramData.callback === 'updateW1') {
                            lenia.U.w1 = calcNormCoef(lenia.U.m1, lenia.U.s1);
                        }
                    });
                    // Handle initial callback if needed
                    if (paramData.callback === 'updateW1') {
                        lenia.U.w1 = calcNormCoef(lenia.U.m1, lenia.U.s1);
                    }
                } else {
                    // Regular param slider (not a uniform)
                    params[paramName] = paramData.value;
                    const slider = folder.add(params, paramName, paramData.min, paramData.max, paramData.step);
                    slider.name(paramData.name || paramName);
                }
            }
            // Array parameters (like spawnCenter, viewCenter) - display in GUI but read-only
            else if (Array.isArray(paramData.value)) {
                params[paramName] = paramData.value;
                // Create a read-only display in GUI showing the current value
                const displayObj = {[paramName]: `[${paramData.value.map(v => typeof v === 'number' ? v.toFixed(2) : v).join(', ')}]`};
                folder.add(displayObj, paramName).name(paramData.name || paramName).listen();
                // Store reference to update display when value changes
                if (!window.guiDisplayObjects) window.guiDisplayObjects = {};
                window.guiDisplayObjects[paramName] = displayObj;
            }
            // Other parameters (just set the value)
            else {
                params[paramName] = paramData.value;
            }
        }
    }

    // Create GUI folders and sliders for life GUI
    for (const [category, catData] of Object.entries(config)) {
        if (category === 'description' || category === 'version') continue;
        if (!catData.params || catData.gui !== 'life') continue;
        
        const folderName = catData.folder || category;
        const folder = lifeGui.addFolder(folderName);
        
        for (const [paramName, paramData] of Object.entries(catData.params)) {
            if (paramData.value === undefined) continue;
            
            // Boolean parameters (checkboxes)
            if (typeof paramData.value === 'boolean') {
                params[paramName] = paramData.value;
                folder.add(params, paramName).name(paramData.name || paramName);
            }
            // Parameters with min/max/step (sliders)
            else if (paramData.min !== undefined && paramData.max !== undefined && paramData.step !== undefined) {
                params[paramName] = paramData.value;
                
                // List of life cycle parameters that are uniforms (need to sync to lenia.U)
                const lifeCycleUniforms = ['resourceAttraction', 'resourceDecay', 'energyDecay', 'feedRate', 
                    'hungerMultiplier', 'reproThreshold', 'reproCost', 'reproMinAge', 'deathDissolveRadius', 
                    'deathEnergyAmount', 'deathEnergyFalloff', 'deathAgeScale', 'hueThreshold'];
                
                // If this is a life cycle uniform, sync it to lenia.U
                if (lifeCycleUniforms.includes(paramName)) {
                    lenia.U[paramName] = paramData.value;  // Initialize uniform from JSON
                    // Create slider that updates both params and lenia.U
                    const slider = folder.add(lenia.U, paramName, paramData.min, paramData.max, paramData.step);
                    slider.name(paramData.name || paramName);
                    // Also keep params in sync for consistency
                    slider.onChange((value) => {
                        params[paramName] = value;
                    });
                } else {
                    // Regular param slider
                    const slider = folder.add(params, paramName, paramData.min, paramData.max, paramData.step);
                    slider.name(paramData.name || paramName);
                }
            }
            // Other parameters (just set the value)
            else {
                params[paramName] = paramData.value;
            }
        }
    }
    
    // Override viewCenter to always start at spawnCenter (after GUI creation so it doesn't get overwritten)
    params.viewCenter = params.spawnCenter.slice(); // Make a copy
    
    // Initialize mobile controls
    const mobileControls = new MobileControls();
    
    // Register mobile control buttons
    mobileControls.registerControl({
        key: 'r',
        label: 'Reset',
        action: () => {
            lenia.reloadResourceImage();
            if (params.spawnCount > lenia.max_point_n) {
                console.warn('spawnCount clamped to max_point_n:', lenia.max_point_n);
            }
            const n = Math.min(params.spawnCount, lenia.max_point_n);
            lenia.reset(n, params.spawnCenter);
            lenia.clearTrails();
        }
    });
    
    mobileControls.registerControl({
        key: '1',
        label: 'Main View',
        action: () => {
            params.renderMode = 1;
            // Update button states
            if (window.mobileControls) {
                const renderModeButtons = window.mobileControls.controls.filter(c => ['1', '2', '3', '4', 'd'].includes(c.key));
                renderModeButtons.forEach(control => {
                    if (control.buttonElement) {
                        control.buttonElement.classList.toggle('active', control.key === '1');
                    }
                });
            }
        }
    });
    
    mobileControls.registerControl({
        key: '2',
        label: 'Trails View',
        action: () => {
            params.renderMode = 2;
            // Update button states
            if (window.mobileControls) {
                const renderModeButtons = window.mobileControls.controls.filter(c => ['1', '2', '3', '4', 'd'].includes(c.key));
                renderModeButtons.forEach(control => {
                    if (control.buttonElement) {
                        control.buttonElement.classList.toggle('active', control.key === '2');
                    }
                });
            }
        }
    });
    
    mobileControls.registerControl({
        key: '3',
        label: 'Reconstruction',
        action: () => {
            params.renderMode = 3;
            lenia.reconstructionUpdateFrame = 0;  // Reset to force immediate update on next render
            lenia.eatenPixelsCache = null;  // Clear cache to force fresh read of eaten pixels
            lenia.createCompressedReconstruction(true).then(reconstruction => {  // Force update
                if (reconstruction && reconstruction.width > 0) {
                    params.viewExtent = Math.max(reconstruction.width, reconstruction.height) * 1.5;
                    params.viewCenter = [0, 0];
                }
            }).catch(err => console.error('Reconstruction failed:', err));
            if (reconstruction && reconstruction.width > 0) {
                params.viewExtent = Math.max(reconstruction.width, reconstruction.height) * 1.5;
                params.viewCenter = [0, 0];
            }
            // Update button states
            if (window.mobileControls) {
                const renderModeButtons = window.mobileControls.controls.filter(c => ['1', '2', '3', '4', 'd'].includes(c.key));
                renderModeButtons.forEach(control => {
                    if (control.buttonElement) {
                        control.buttonElement.classList.toggle('active', control.key === '3');
                    }
                });
            }
        }
    });
    
    mobileControls.registerControl({
        key: '4',
        label: 'Depth map',
        action: () => {
            params.renderMode = 4;
            if (window.mobileControls) {
                const renderModeButtons = window.mobileControls.controls.filter(c => ['1', '2', '3', '4', 'd'].includes(c.key));
                renderModeButtons.forEach(control => {
                    if (control.buttonElement) {
                        control.buttonElement.classList.toggle('active', control.key === '4' || control.key === 'd');
                    }
                });
            }
        }
    });
    mobileControls.registerControl({
        key: 'd',
        label: 'Depth map view (same as 4)',
        action: () => {
            params.renderMode = 4;
            if (window.mobileControls) {
                const renderModeButtons = window.mobileControls.controls.filter(c => ['1', '2', '3', '4', 'd'].includes(c.key));
                renderModeButtons.forEach(control => {
                    if (control.buttonElement) {
                        control.buttonElement.classList.toggle('active', control.key === '4' || control.key === 'd');
                    }
                });
            }
        }
    });
    
    mobileControls.registerControl({
        key: 'q',
        label: 'Toggle Graph',
        isToggle: true,
        action: () => {
            params.showCellGraph = !params.showCellGraph;
            // Update button state after toggle
            if (window.mobileControls) {
                window.mobileControls.updateButtonState('q', params.showCellGraph);
            }
        }
    });
    
    mobileControls.registerControl({
        key: 't',
        label: 'Trails Overlay',
        isToggle: true,
        action: () => {
            params.showTrailsOverlay = !params.showTrailsOverlay;
            if (window.mobileControls) {
                window.mobileControls.updateButtonState('t', params.showTrailsOverlay);
            }
        }
    });
    
    mobileControls.registerControl({
        key: ' ',
        label: 'Play / Pause',
        isToggle: true,
        action: () => {
            params.paused = !params.paused;
            if (window.mobileControls) window.mobileControls.updateButtonState(' ', params.paused);
        }
    });
    
    // Expose mobileControls globally for potential future use
    window.mobileControls = mobileControls;
    
    // Set initial button states for toggle buttons
    setTimeout(() => {
        mobileControls.updateButtonState('q', params.showCellGraph);
        mobileControls.updateButtonState('t', params.showTrailsOverlay);
        mobileControls.updateButtonState(' ', params.paused);
        // Set active state for current render mode
        const renderModeButtons = mobileControls.controls.filter(c => ['1', '2', '3', '4', 'd'].includes(c.key));
        renderModeButtons.forEach(control => {
            if (control.buttonElement) {
                const isActive = (control.key === '4' || control.key === 'd') ? params.renderMode === 4 : parseInt(control.key) === params.renderMode;
                control.buttonElement.classList.toggle('active', isActive);
            }
        });
    }, 100);
    
    // Help overlay: build key list from mobileControls only
    function buildHelpKeys() {
        const tbody = document.getElementById('helpKeysBody');
        if (!tbody) return;
        const controls = (window.mobileControls && window.mobileControls.controls) ? [...window.mobileControls.controls] : [];
        tbody.innerHTML = controls.map(c => {
            const keyDisplay = c.key === ' ' ? '‚ê£' : c.key;
            return `<tr><td><span class="key-cap">${keyDisplay}</span></td><td>${c.label}</td></tr>`;
        }).join('');
    }
    const helpOverlay = document.getElementById('helpOverlay');
    const helpOverlayBtn = document.getElementById('helpOverlayBtn');
    const helpOverlayClose = document.getElementById('helpOverlayClose');
    if (helpOverlayBtn) {
        helpOverlayBtn.addEventListener('click', () => {
            buildHelpKeys();
            if (helpOverlay) helpOverlay.classList.add('visible');
        });
    }
    if (helpOverlayClose) {
        helpOverlayClose.addEventListener('click', () => {
            if (helpOverlay) helpOverlay.classList.remove('visible');
        });
    }
    if (helpOverlay) {
        helpOverlay.addEventListener('click', (e) => {
            if (e.target === helpOverlay) helpOverlay.classList.remove('visible');
        });
    }
    
    gui.add(params, 'benchmark');
    gui.add(params, 'toggle sound');
    gui.add(params, 'init circle');
    gui.add(params, 'fullscreen');
    gui.add(params, 'oscillogram');

    // Resource management
    const resourceFolder = gui.addFolder('Resources');
    params['load resource'] = () => resourceInput.click();
    params['clear resources'] = () => lenia.clearResources();
    params.consumeEnabled = getParamValue(paramMap, 'consumeEnabled', true);
    resourceFolder.add(params, 'load resource');
    resourceFolder.add(params, 'clear resources');
    resourceFolder.add(params, 'consumeEnabled').name('consume resources');

    // Depth map (optional constraint)
    const depthFolder = gui.addFolder('Depth map');
    params['load depth'] = () => depthInput.click();
    params['clear depth'] = () => lenia.clearDepth();
    depthFolder.add(params, 'load depth');
    depthFolder.add(params, 'clear depth');
    const depthEnabledController = depthFolder.add(lenia.U, 'depthEnabled').name('use depth map');
    depthEnabledController.onChange((value) => {
        if (value) lenia.ensureDepthFromResource();
    });
    window.depthEnabledController = depthEnabledController;
    depthFolder.add(lenia.U, 'depthStrength', 0, 5, 0.1).name('strength');
    depthFolder.add(lenia.U, 'depthGradientSign', -1, 1, 0.1).name('gradient sign (+ toward high)');
    depthFolder.add(lenia.U, 'depthBand', 0.01, 0.5, 0.01).name('connectivity band');
    depthFolder.add(lenia.U, 'depthMode', { Gradient: 0, Connectivity: 1 }).name('mode');

    // Life Cycle toggles
    params.enableLifeCycle = getParamValue(paramMap, 'enableLifeCycle', true);
    params.enableDeaths = getParamValue(paramMap, 'enableDeaths', true);
    params.enableReproduction = getParamValue(paramMap, 'enableReproduction', true);

    const lifeFolder = lifeGui.addFolder('üß¨ Life Cycle');
    lifeFolder.add(params, 'enableLifeCycle').name('enable life cycle');
    lifeFolder.add(params, 'enableDeaths').name('enable deaths');
    lifeFolder.add(params, 'enableReproduction').name('enable reproduction');
    lifeGui.close();

    // Hidden file input for resource images
    const resourceInput = document.createElement('input');
    resourceInput.type = 'file';
    resourceInput.accept = 'image/*';
    resourceInput.style.display = 'none';
    document.body.appendChild(resourceInput);
    resourceInput.addEventListener('change', async (e) => {
        if (resourceInput.files.length > 0) {
            const file = resourceInput.files[0];
            const dataUrl = await asyncReadAsDataURL(file);
            await lenia.loadResourceImage(dataUrl);
            console.log('Loaded resource image:', file.name);
        }
    });

    // Hidden file input for depth map (grayscale)
    const depthInput = document.createElement('input');
    depthInput.type = 'file';
    depthInput.accept = 'image/*';
    depthInput.style.display = 'none';
    document.body.appendChild(depthInput);
    depthInput.addEventListener('change', async (e) => {
        if (depthInput.files.length > 0) {
            const file = depthInput.files[0];
            const dataUrl = await asyncReadAsDataURL(file);
            await lenia.loadDepthImage(dataUrl);
            console.log('Loaded depth map:', file.name);
        }
    });

    // Load default resource image on startup
    try {
        await lenia.loadResourceImage('zenarnie.jpg');
        console.log('Loaded default resource image: zenarnie.jpg');
    } catch (err) {
        console.log('Could not load default resource image:', err);
        // Continue without default image if it fails
    }

let onair = false;

const nextFrame = () => new Promise(requestAnimationFrame);


function fullscreen() {
  if (!document.fullscreenElement) {
    canvas.requestFullscreen();
  } else if (document.exitFullscreen) {
    document.exitFullscreen();
  }
}

const previewSize = 256 ;
const previewFB = twgl.createFramebufferInfo(gl, null, previewSize, previewSize);
previewFB.canvas = document.createElement('canvas');
previewFB.canvas.width = previewFB.canvas.height = previewSize;
previewFB.ctx = previewFB.canvas.getContext('2d', { willReadFrequently: true });
previewFB.im = previewFB.ctx.getImageData(0, 0, previewSize, previewSize);


    function bench() {
        lenia.reset(params.spawnCount, params.spawnCenter);
        const t=Date.now(), n=1000;
        for (let i=0; i<n; ++i) lenia.step();
        lenia.fetchState();
        const dt = (Date.now()-t)/n;
        document.getElementById('stat').innerText = `${dt.toFixed(2)} ms/step`;
    }
    bench();


function simFrame(stepArgs, audioFB, sampleRate=48000) {
    const samplesPerFrame = sampleRate/fps;
    if (audioFB) {
        console.assert(sampleRate%fps == 0);
        console.assert(audioFB.width >= samplesPerFrame);
    }
    const {stepN} = stepArgs;
    for (let i=0, p0=0; i<stepN; ++i) {
        const p1 = Math.round((i+1)*samplesPerFrame/stepN);
        lenia.step({...stepArgs, clockRate:(p1-p0)/sampleRate});
        if (audioFB) {
            lenia.renderAudio(audioFB, [p0, 0, p1-p0, 1]);
        }
        p0 = p1;
    }
    if (audioFB) {
        twgl.bindFramebufferInfo(gl, audioFB);
        gl.readPixels(0, 0, samplesPerFrame, 1, gl.RG, gl.FLOAT, audioFB.cpu);
    }
}

let recording = false;
let record_log = [];

async function saveRecord() {
    const rec = new VideoWriter('rec');
    await rec.start();
    for (const r of record_log) {
        if ('state' in r) {
            lenia.pushState(r.state);
        }
        if ('setPoint' in r) {
            const {i, xy} = r.setPoint;
            lenia.setPoint(i, xy);
        }
        if ('stepArgs' in r) {
            simFrame(r.stepArgs, rec.audioFB, rec.sampleRate);
        }
        if ('renderArgs' in r) {
            lenia.render(rec.fb, {...r.renderArgs, flipUD:true});
            await rec.frame();
            if (rec.frameCount%10==0) {
                lenia.render(null, r.renderArgs);
                lenia.visAudio(null, rec.audioFB.attachments[0]);
                await nextFrame();
            }
        }
    }
    await rec.close();
}

async function toggleRecord() {
    if (!recording) {
        record_log = [{state:lenia.fetchState()}];
        recording = true;
    } else {
        recording = false;
        try {
            onair = true;
            await saveRecord();
        } finally {
            onair = false;
            requestAnimationFrame(animate);
        }
    }
    console.log('recording:', recording)
}

// FPS tracking and limiting
let fpsFrameCount = 0;
let fpsLastTime = performance.now();
let lastFrameTime = 0;
let lastCellCount = 0;

// Cell count graph
const cellGraph = document.getElementById('cellGraph');
const cellCtx = cellGraph.getContext('2d');
let cellHistory = [];
const maxCellSamples = 600;  // last 10 seconds at 60 FPS

function updateCellGraph() {
    if (!params.showCellGraph) {
        cellGraph.style.display = 'none';
        return;
    }
    cellGraph.style.display = 'block';

    // Push current count every frame
    const count = lenia.getAliveCount();
    cellHistory.push(count);
    if (cellHistory.length > maxCellSamples) cellHistory.shift();

    // Resize to current viewport
    cellGraph.width = cellGraph.clientWidth;
    cellGraph.height = cellGraph.clientHeight;

    const w = cellGraph.width;
    const h = cellGraph.height;
    const maxCount = lenia.max_point_n;

    cellCtx.clearRect(0, 0, w, h);

    // Axes
    cellCtx.strokeStyle = 'rgba(255,255,255,0.1)';
    cellCtx.beginPath();
    cellCtx.moveTo(0, h-0.5);
    cellCtx.lineTo(w, h-0.5);
    cellCtx.stroke();

    // Line
    if (cellHistory.length > 0) {
        cellCtx.strokeStyle = '#4af2a1';
        cellCtx.lineWidth = 2;
        cellCtx.beginPath();
        cellHistory.forEach((c, i) => {
            const x = (i / Math.max(1, cellHistory.length - 1)) * w;
            const y = h - (c / maxCount) * (h - 4) - 2;
            if (i === 0) cellCtx.moveTo(x, y); else cellCtx.lineTo(x, y);
        });
        cellCtx.stroke();
    }
}

function animate(currentTime) {
    if (onair) return;
    
    // FPS limiting - skip frame if too soon
    const targetInterval = 1000 / params.targetFPS;
    if (currentTime - lastFrameTime < targetInterval) {
        requestAnimationFrame(animate);
        return;
    }
    lastFrameTime = currentTime;
    
    // When paused, only re-render current state (no step)
    if (params.paused) {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        if (canvas.width < 768) {
            canvas.width = canvas.clientWidth * window.devicePixelRatio;
            canvas.height = canvas.clientHeight * window.devicePixelRatio;
        }
        const touchRadius = params.touchRadius * params.viewExtent;
        const renderArgs = { touchPos: params.mousePos, touchRadius, viewCenter: params.viewCenter, viewExtent: params.viewExtent };
        if (params.renderMode === 1) {
            lenia.render(null, renderArgs);
            if (params.showTrailsOverlay) lenia.renderTrailsOverlay(null, renderArgs);
        } else if (params.renderMode === 2) {
            lenia.renderTrails(null, renderArgs);
        } else if (params.renderMode === 3) {
            lenia.renderCompressedReconstruction(null, renderArgs);
        } else if (params.renderMode === 4) {
            lenia.renderDepthMap(null, renderArgs);
            if (params.showTrailsOverlay) lenia.renderTrailsOverlay(null, renderArgs);
        } else {
            lenia.render(null, renderArgs);
            if (params.showTrailsOverlay) lenia.renderTrailsOverlay(null, renderArgs);
        }
        updateCellGraph();
        requestAnimationFrame(animate);
        return;
    }
    
    // Update FPS counter
    fpsFrameCount++;
    const now = performance.now();
    const modeNames = ['', 'Main', 'Trails', 'Compressed', 'Depth map'];
    const modeName = modeNames[params.renderMode] || `Mode ${params.renderMode}`;
    if (now - fpsLastTime >= 1000) {
        lastCellCount = lenia.getAliveCount();
        const rgbdError = lenia.reconstructionRGBd;
        const ssimValue = lenia.reconstructionSSIM;
        let errorDisplay = '';
        // Display metrics if they are defined and not null
        // RGBd should be > 0 for a valid reconstruction (large number)
        // SSIM can be 0 (poor match) or up to 1 (perfect match)
        const hasRGBd = (rgbdError != null && rgbdError !== undefined && rgbdError > 0);
        const hasSSIM = (ssimValue != null && ssimValue !== undefined);
        
        // Add reconstruction info (count and resolution) in green
        const reconInfo = lenia.lastReconstructionDims 
            ? `<span style="color: #4af2a1;">${lenia.reconstructionCount || 0} reconstruction ${lenia.lastReconstructionDims.width}x${lenia.lastReconstructionDims.height}</span>`
            : '';
        
        // Build metrics line (colored stuff on second line)
        let metricsLine = '';
        if (hasRGBd || hasSSIM || reconInfo) {
            const rgbdDisplay = hasRGBd ? `<span style="color: #ff8800;">RGBd: ${rgbdError.toLocaleString()}</span>` : '';
            const ssimDisplay = hasSSIM ? `<span style="color: #cc88ff;">SSIM: ${ssimValue.toFixed(3)}</span>` : '';
            
            // Combine all parts with separators
            const parts = [rgbdDisplay, ssimDisplay, reconInfo].filter(p => p);
            metricsLine = parts.join(' | ');
        }
        
        // Split into two lines: main stats on first line, colored metrics on second line
        const mainLine = `${fpsFrameCount} FPS | [${params.renderMode}] ${modeName} | cells: ${lastCellCount} | steps: ${params.stepN} | world ${lenia.worldTexSize}√ó${lenia.worldTexSize}`;
        const displayHTML = metricsLine 
            ? `${mainLine}<br>${metricsLine}`
            : mainLine;
        document.getElementById('fps').innerHTML = displayHTML;
        fpsFrameCount = 0;
        fpsLastTime = now;
    }
    
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    // for very small viewports or mobile devices, render at native res
    if (canvas.width < 768) {
        canvas.width = canvas.clientWidth * window.devicePixelRatio;
        canvas.height = canvas.clientHeight * window.devicePixelRatio;;
    }

    const touchRadius = params.touchRadius * params.viewExtent;
    const renderArgs = {touchPos: params.mousePos, touchRadius,
        viewCenter: params.viewCenter,
        viewExtent: params.viewExtent};

    let action = '';
    if (params.mouseDown) {
        action = params.shiftKey ? 'add' : 'attract';
    }
    if (action == 'add') {
        lenia.setPoint(params.pointAddI, params.mousePos);
        if (recording) { record_log.push(
            {setPoint: {i:params.pointAddI, xy:params.mousePos}});}
        params.pointAddI = (params.pointAddI+1)%lenia.max_point_n;
    }
    const stepArgs = {
        attractPos: params.mousePos,
        attractRadius:action=='attract'?touchRadius:0.0,
        stepN: params.stepN,
    };
    if (audioSystem.playing && audioSystem.audioQueueLen<5) {
        const k = 1+(audioSystem.audioQueueLen < 3);
        for (let i=0; i<k; ++i) {
            simFrame(stepArgs, audioSystem.audioFB, audioSystem.sampleRate);
            audioSystem.push();
            if (recording) { record_log.push({stepArgs, renderArgs});}
        }
    } else {
        simFrame(stepArgs, null);
        if (recording) { record_log.push({stepArgs, renderArgs});}
    }
    
    // Consume resources where particles are located
    if (params.consumeEnabled) {
        lenia.consumeResources();
    }
    
    // Life cycle processing
    if (params.enableLifeCycle) {
        if (params.enableDeaths) {
            lenia.processDeaths();
        }
        if (params.enableReproduction) {
            if (params.useCpuRepro) {
                // CPU-side reproduction: check only every K steps
                if ((lenia.stepCount || 0) % params.reproInterval === 0) {
                    lenia.cpuReproductionStep(params.maxChildrenPerParent);
                }
            } else {
                // Original GPU-only reproduction (can create large bursts)
                lenia.processReproduction();
            }
        }
    }
    
    // Always accumulate trails (even when not viewing them)
    lenia.accumulateTrails();
    
    // Render based on current mode
    if (params.renderMode === 1) {
        lenia.render(null, renderArgs);  // Main view
        if (params.showTrailsOverlay) {
            lenia.renderTrailsOverlay(null, renderArgs);  // Trails overlaid on main (key "t")
        }
    } else if (params.renderMode === 2) {
        lenia.renderTrails(null, renderArgs);  // Trail view
    } else if (params.renderMode === 3) {
        lenia.renderCompressedReconstruction(null, renderArgs);  // Compressed reconstruction
    } else if (params.renderMode === 4) {
        lenia.renderDepthMap(null, renderArgs);  // Depth map display (key "d" or "4")
        if (params.showTrailsOverlay) {
            lenia.renderTrailsOverlay(null, renderArgs);
        }
    } else {
        lenia.render(null, renderArgs);  // Default to main
        if (params.showTrailsOverlay) {
            lenia.renderTrailsOverlay(null, renderArgs);
        }
    }
    
    // Update cell count graph
    updateCellGraph();
    
    if (audioSystem.playing && params.oscillogram) {
         lenia.visAudio(null, audioSystem.audioFB.attachments[0])
    }
    requestAnimationFrame(animate);
}

    function event2wld(XY) {
        const w=canvas.clientWidth, h=canvas.clientHeight;
        const ext = window.params.viewExtent;
        const aspect = w/Math.max(h, 1);
        const [cx, cy] = window.params.viewCenter;
        return [ext*(XY[0]/w-0.5)+cx, ext*(0.5/aspect-XY[1]/w)+cy];
    }

    // dontSave prevents us adding back to zoo
    function captureCreature(dontSave = false, existingData = {}, preTextImg, container, append = false) {
        // we already have an image so no need to recapture
        data = existingData;
        if (preTextImg == undefined) {
            c = lenia.captureCreature();
        if (!c) return;
        data = Object.assign(data, c.data, existingData); // existingData should always overwrite
    } 

    if (!data.name || data.name.trim() == "") {
        let conflict = true;
        let idx = Math.floor(Math.random() * NAMES.length);
        let attempts = 0;
        while(conflict && (attempts < 20)){
            idx = Math.floor(Math.random() * NAMES.length);
            conflict = localZoo.some(c => c.name == NAMES[idx]);
            attempts += 1;
        }
        if (attempts == 20) console.log("unable to find unique name for new creature");
        data.name = NAMES[idx]; 
    }

    // add url
    if (preTextImg == undefined) {
        lenia.render(previewFB, {viewCenter: c.center, viewExtent: c.extent, selectedOnly: true, flipUD: true});
        gl.readPixels(0, 0, previewSize, previewSize, gl.RGBA, gl.UNSIGNED_BYTE, previewFB.im.data);
        for (let i=3; i<previewFB.im.data.length; i+=4) {previewFB.im.data[i] = 255}
        preTextImg = previewFB.im; // previewFB.ctx.getImageData(0, 0, previewSize, previewSize); //previewFB.canvas.toDataURL("image/png");
        previewFB.ctx.putImageData(previewFB.im, 0, 0);
    } else {
        previewFB.ctx.putImageData(preTextImg, 0, 0); //drawImage(preTextImg, 0, 0);
    }

    const textOffsetX = 8;
    const textOffsetY = 7;

    // safari from earlier this year still doesn't have roundrect (funnily enough, for Apple who loves rounded rects)
    if (!("roundRect" in previewFB.ctx)){
        previewFB.ctx.roundRect = previewFB.ctx.rect;
    }

    previewFB.ctx.resetTransform();
    previewFB.ctx.beginPath();
    previewFB.ctx.font = '20px sans-serif';
    previewFB.ctx.fillStyle = 'rgba(0,0,0,0.5)';
    let tWidth = previewFB.ctx.measureText(data.name).width
    previewFB.ctx.roundRect(-10, -10, tWidth + 10 + textOffsetX*2, 30 + 10, 10);
    previewFB.ctx.fill();

    previewFB.ctx.beginPath();
    previewFB.ctx.font = '20px sans-serif';
    previewFB.ctx.fillStyle = 'rgba(0,0,0,0.5)';
    tWidth = previewFB.ctx.measureText('znah.net/lenia').width
    previewFB.ctx.roundRect(256 + 10, 256 + 10, -(tWidth + 10 + textOffsetX*2), -(30 + 10), 10);
    previewFB.ctx.fill();

    previewFB.ctx.resetTransform();
    previewFB.ctx.font = '20px sans-serif';
    previewFB.ctx.fillStyle = "#d4d4d4"; 
    // previewFB.ctx.shadowBlur = 8;
    // previewFB.ctx.shadowColor = 'black';
    previewFB.ctx.fillText('znah.net/lenia', 256 - (122 + textOffsetX), 256 - textOffsetY);
    previewFB.ctx.fillText(data.name, textOffsetX, textOffsetY + 15);

    previewFB.im = previewFB.ctx.getImageData(0, 0, previewSize, previewSize);

    // TODO(DONE): this is the right place to inject the data
    previewPNGView = new PNGView(previewFB.im.data.buffer);
    const enc_some_creature = serialize(data, 0x2, previewPNGView);
    previewFB.ctx.putImageData(previewFB.im, 0, 0);


    // a elements allow custom filenames for download
    if (container == undefined){
        container = document.createElement('div'); container.className = "previewContainer";
        if (append) {
            $('#zoo').insertBefore(container, $('#uploadButton'));
        } else {
            $('#zoo').prepend(container);
        }
    }

    const overlay = document.createElement('div'); overlay.className = "previewOverlay"; 
    overlay.innerHTML = "<span id='download'>‚¨áÔ∏è </span><span id='pencil'>‚úèÔ∏è </span><span id='eraser'>‚ùå </span>";
    overlay.onclick = ((e) => {
        var localData = data;
        return (event) => {
            if (event.target.id == "eraser"){
                // remove from zoo?
                localZoo.find
                var index = localZoo.indexOf(localData);
                if (index !== -1) {
                  localZoo.splice(index, 1);
                } else {
                    console.log("can't delete creature. not found in zoo.")
                }
                localStorage["ZOO"] = JSON.stringify(localZoo);
                // remove DOM element
                container.remove()
            } else if (event.target.id == "pencil") {
                event.preventDefault(); 
                overlay.style.top = "0px";
                overlay.style.bottom = "auto";
                overlay.style.right = "0px"
                overlay.style.left = "auto"
                overlay.style.width = "100%";
                overlay.style.backgroundColor = "rgb(19, 21, 59)";
                overlay.innerHTML = localData.name;
                overlay.setAttribute('contenteditable', true); 
                document.body.style["user-select"] = "text";
                document.body.style["-webkit-touch-callout"] = "text";
                document.body.style["-webkit-user-select"] = "text";
                overlay.focus(); 
            } else if (event.target.id == "download") {
                link = document.createElement("a");
                link.setAttribute("href", previewFB.canvas.toDataURL("image/png"));
                link.setAttribute("download", localData.name + ".png");
                link.click();
            }
        }
    })();
    overlay.addEventListener('focusout', (() => {
        var localData = data;
        return (event) => {
            // data should be a reference still to the same object in localZoo, so we can dump it back in.
            localData.name = overlay.innerText;
            overlay.innerHTML = "‚úèÔ∏è";
            overlay.style.bottom = "7px";
            overlay.style.top = "auto";
            overlay.style.left = "5px";
            overlay.style.right = "auto"
            overlay.style.width = "auto";
            overlay.style.backgroundColor = "none";
            overlay.setAttribute('contenteditable', false); 
            document.body.style["user-select"] = "none";
            document.body.style["-webkit-touch-callout"] = "none";
            document.body.style["-webkit-user-select"] = "none";
            captureCreature(true, localData, preTextImg, container);
            localStorage["ZOO"] = JSON.stringify(localZoo);
        }
    })()
    );
    const img_a = document.createElement('a');
    const img = document.createElement('img');
    img.src = img_a.href = previewFB.canvas.toDataURL("image/png");
    img_a.download = data.name + ".png"; 
    img.classList.add('preview');
    img_a.appendChild(img);
    img_a.onclick = (() => { 
        var localData = data;
        return (e) => {
            e.preventDefault();
            pasteCreature(localData, 0.0, 0.0);
        };
    })();

    if (!container.hasChildNodes()){
        container.appendChild(img_a)
        container.appendChild(overlay);
    } else {
        container.replaceChild(img_a, container.firstChild)
        container.replaceChild(overlay, container.lastChild)
    }

    // TODO(DONE): data should be stored in pixels
    // can't actually check for DownloadURL support, directly, so unfortunately browser detection 
    if (!(/^((?!chrome|android).)*safari/i.test(navigator.userAgent))) {
        img.ondragstart = img_a.ondragstart = (() => {
            var localData = data;
            return ((e) => {
                // undocumented chrome feature to set filename when drag and dropping to file browser
                e.dataTransfer.setData("DownloadURL", "image/png:" + localData.name + ".png:" + img.src)
            });
        })();
    }

    // save to local zoo
    if (!dontSave){
        if (append) {
            localZoo.unshift(data);
        } else {
            localZoo.push(data);
        }
        localStorage["ZOO"] = JSON.stringify(localZoo);
    }

    return data;
}

window.addEventListener('keydown', e=>{
    if (e.key == ' ') {
        e.preventDefault();
        params.paused = !params.paused;
        if (window.mobileControls) window.mobileControls.updateButtonState(' ', params.paused);
    }
    if (e.key == 'r') {
        // If a texture was loaded, reload it; otherwise just reset particles
        lenia.reloadResourceImage(); // Reloads original texture if one exists (also clears reconstruction cache)
        // Clamp spawnCount to max_point_n to avoid overflow
        if (params.spawnCount > lenia.max_point_n) {
            console.warn('spawnCount clamped to max_point_n:', lenia.max_point_n);
        }
        const n = Math.min(params.spawnCount, lenia.max_point_n);
        lenia.reset(n, params.spawnCenter);
        lenia.clearTrails(); // Also clear trail accumulation
    }
    // Render mode switching (1-9)
    if (e.key >= '1' && e.key <= '9') {
        params.renderMode = parseInt(e.key);
        // When switching to mode 3 (compressed reconstruction), set reasonable view extent
        // Clear caches and reset frame counter to force fresh update (handles case where user switches after long delay)
        if (params.renderMode === 3) {
            lenia.reconstructionUpdateFrame = 0;  // Reset to force immediate update on next render
            lenia.eatenPixelsCache = null;  // Clear cache to force fresh read of eaten pixels
            lenia.createCompressedReconstruction(true).then(reconstruction => {  // Force update
                if (reconstruction && reconstruction.width > 0) {
                    // Set viewExtent to show the image at a reasonable size (about 1.5x the image size)
                    params.viewExtent = Math.max(reconstruction.width, reconstruction.height) * 1.5;
                    params.viewCenter = [0, 0];  // Center the view
                }
            }).catch(err => console.error('Reconstruction failed:', err));
        }
        // Update mobile control button states for render mode buttons
        if (window.mobileControls) {
            const renderModeButtons = window.mobileControls.controls.filter(c => ['1', '2', '3', '4', 'd'].includes(c.key));
            renderModeButtons.forEach(control => {
                if (control.buttonElement) {
                    const isActive = (control.key === '4' || control.key === 'd') ? params.renderMode === 4 : parseInt(control.key) === params.renderMode;
                    control.buttonElement.classList.toggle('active', isActive);
                }
            });
        }
    }
    // Toggle cell count graph
    if (e.key === 'q' || e.key === 'Q') {
        params.showCellGraph = !params.showCellGraph;
        // Update mobile control button state
        if (window.mobileControls) {
            window.mobileControls.updateButtonState('q', params.showCellGraph);
        }
    }
    // Toggle trails overlay on main view (key "t")
    if (e.key === 't' || e.key === 'T') {
        params.showTrailsOverlay = !params.showTrailsOverlay;
        if (window.mobileControls) {
            window.mobileControls.updateButtonState('t', params.showTrailsOverlay);
        }
    }
    // Depth map display mode (key "d" or "4") - show current depth texture
    if (e.key === 'd' || e.key === 'D') {
        params.renderMode = 4;
        if (window.mobileControls) {
            const renderModeButtons = window.mobileControls.controls.filter(c => ['1', '2', '3', '4', 'd'].includes(c.key));
            renderModeButtons.forEach(control => {
                if (control.buttonElement) {
                    control.buttonElement.classList.toggle('active', control.key === '4' || control.key === 'd');
                }
            });
        }
    }
});

let pointerCache = [];
let lastTapTime = 0;
let lastTapLoc = null;

/* multi-touch intended behaviour

- one touch changes to panning icon, moves canvas around in space
- two touch points moves around in space, pinch distance changes zoomo
- long-touch of a single point picks up particles till they are dropped 
- any more pointers in addition to the single one do zoom/pan

*/
canvas.addEventListener("pointerdown", e => {
    e.preventDefault();
    if (e.shiftKey || (lastTapTime != null && (Date.now() - lastTapTime < 600) &&  
        (Math.sqrt((e.offsetX - lastTapLoc[0])**2 + (e.offsetY - lastTapLoc[1])**2) <= canvas.width * 0.05)) ) params.shiftKey = true;
    if (e.shiftKey || (lastTapTime != null && (Date.now() - lastTapTime < 600) &&  
        (Math.sqrt((e.offsetX - lastTapLoc[0])**2 + (e.offsetY - lastTapLoc[1])**2) <= canvas.width * 0.05))) {
        params.mouseDown = true;
        params.mousePos = event2wld([e.offsetX, e.offsetY]);
        return;
    }

    lastTapLoc = [e.offsetX, e.offsetY];
    lastTapTime = new Date().getTime();

    const pointer = {
        "pId": e.pointerId,
        "startXY": [e.offsetX, e.offsetY], 
        "lastXY": [e.offsetX, e.offsetY], 
        "state": "init" // state machine of "init", "move", "interact" 
    };

    pointer.timeOutId = setTimeout(() => {
        pointer.state = "interact";
        params.mousePos = event2wld([e.offsetX, e.offsetY]);
        params.mouseDown = true;
    }, 500),

    pointerCache.push(pointer);
});

// Double-click to set spawn center for next reset
canvas.addEventListener('dblclick', e => {
    e.preventDefault();
    const [x, y] = event2wld([e.offsetX, e.offsetY]);
    params.spawnCenter = [x, y];
    // Format values with 2 decimal places for JSON
    const xFormatted = parseFloat(x.toFixed(2));
    const yFormatted = parseFloat(y.toFixed(2));
    console.log('Spawn center set to:', [xFormatted, yFormatted]);
    console.log('Update parameters.json with: "spawnCenter": { "value": [' + xFormatted + ', ' + yFormatted + '] }');
    
    // Update GUI display if it exists
    if (window.guiDisplayObjects && window.guiDisplayObjects.spawnCenter) {
        window.guiDisplayObjects.spawnCenter.spawnCenter = `[${xFormatted}, ${yFormatted}]`;
    }
});

// document.addEventListener('selectionchange', (event) => {
//     event.preventDefault();
//     document.getSelection().removeAllRanges();
// });

canvas.addEventListener("pointermove", e => {
    e.preventDefault();

    if (params.shiftKey) {
        params.mousePos = event2wld([e.offsetX, e.offsetY]);
        return;
    } 

    const index = pointerCache.findIndex((pointer) => pointer.pId === e.pointerId);
    if (e.buttons <= 0 || index == -1) return;
    const p = pointerCache[index]; 

    const moveFar = () => (Math.sqrt((e.offsetX - p.startXY[0])**2 + (e.offsetY - p.startXY[1])**2) > canvas.width * 0.02);

    if (p.state == "init" && moveFar()) {
        clearTimeout(p.timeOutId); 
        p.state = "move"; 
    }

    if (p.state == "move" || p.state == "init") {
        let lXY = p.lastXY;
        let cXY = [e.offsetX, e.offsetY];
        let s = 1.0;

        // incorporate second touch if available
        const otherTouch = pointerCache.findIndex(op => (op.state == "move" && op.pId != e.pointerId));
        if (otherTouch > -1) {
            let oXY = pointerCache[otherTouch].lastXY;  

            // zoom extent
            ldiff = Math.sqrt((lXY[0] - oXY[0])**2 + (lXY[1] - oXY[1])**2); 
            ndiff = Math.sqrt((cXY[0] - oXY[0])**2 + (cXY[1] - oXY[1])**2); 
            s = ldiff/ndiff;

            // movement
            lXY = [((lXY[0] + oXY[0]) / 2), ((lXY[1] + oXY[1]) / 2)]
            cXY = [((cXY[0] + oXY[0]) / 2), ((cXY[1] + oXY[1]) / 2)]
        }

        let [x, y] = params.viewCenter;
        let [deltaX, deltaY] = [lXY[0] - cXY[0], lXY[1] - cXY[1]]; 
        deltaX *= (params.viewExtent/canvas.clientWidth)
        deltaY *= (params.viewExtent/canvas.clientWidth)
        x = x + deltaX; y = y - deltaY;
        const d = Math.sqrt(x*x+y*y);
        if (d>lenia.dishR) {
            x *= lenia.dishR/d; y *= lenia.dishR/d;
        }
        params.viewCenter = [x, y]

        // pinch to zoom if needed
        if (otherTouch > -1){
            const [x, y] = event2wld(cXY);
            const ext = params.viewExtent*s;
            params.viewExtent = Math.max(4.0, Math.min(ext, lenia.dishR*4.0));
            if (params.viewExtent == ext) {
                const [cx, cy] = params.viewCenter;
                params.viewCenter = [x+(cx-x)*s, y+(cy-y)*s];
            }
        }

        // if we are holding particles with another touch, update their pos
        const grabTouch = pointerCache.findIndex(op => (op.state == "interact"));
        if (grabTouch > -1) {
            params.mousePos = event2wld(pointerCache[grabTouch].lastXY);
        }

        p.lastXY = [e.offsetX, e.offsetY]; 
    }

    if (p.state == "interact") {
        params.mousePos = event2wld([e.offsetX, e.offsetY]);
    }
});

["pointerup", "pointerout"].forEach(listenerName => {
    canvas.addEventListener(listenerName, e => {
        e.preventDefault();
        lastTapLoc = [e.offsetX, e.offsetY];
        if (params.shiftKey) {
            params.mousePos = event2wld([e.offsetX, e.offsetY]);
            params.mousePos = [-10000, -10000];
            params.shiftKey = false;
            params.mouseDown = false;
            return;
        }
        params.shiftKey = false;
        const index = pointerCache.findIndex((pointer) => pointer.pId === e.pointerId);
        if (index == -1) return;
        const p = pointerCache[index]; 
        if (p.state == "interact") {
            params.mouseDown = false;
            params.mousePos = [-10000, -10000];
        }
        pointerCache.splice(index, 1); 
        clearTimeout(p.timeOutId);
    });
});

canvas.addEventListener('mouseleave', e => {
    params.mousePos = [-10000, -10000];
});

canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    const [x, y] = event2wld([e.offsetX, e.offsetY]);
    const s = Math.exp(e.deltaY*0.01);
    const ext = params.viewExtent*s;
    params.viewExtent = Math.max(4.0, Math.min(ext, lenia.dishR*4.0));
    if (params.viewExtent == ext) {
        const [cx, cy] = params.viewCenter;
        params.viewCenter = [x+(cx-x)*s, y+(cy-y)*s];
    }
}, {passive: false});


function pasteCreature(c, x, y, selected=0) {
    lenia.pasteCreature(c, x, y, selected);
    gui.updateDisplay()
    // for (const name of 'dt m1 s1 m2 s2 repulsion'.split(' ')) {
    //     $(`#controls #${name}`).value = c[name];
    // }
}

// TODO(DONE): remove when PNG-based creature storage is implemented
// pre-load a few creatures from ZOO into local storage if they aren't already there.
// if the local storage is already initialized, then we don't load these creatures
// assume that if a user removed them, they don't want them back. we can provide
// a "reset zoo" button if necessary.
if (localStorage.getItem("ZOO") === null || JSON.parse(localStorage.getItem("ZOO")).length == 0) {
    localStorage.setItem("ZOO", JSON.stringify(ZOO));
} 
const localZoo = JSON.parse(localStorage.getItem("ZOO"))
localZoo.forEach(c=>{
    pasteCreature(c, 0.0, 0.0, 1.0);
    captureCreature(true, c);
});

pasteCreature(localZoo[0], 0.0, 0.0, 1.0);
lenia.reset(params.spawnCount, params.spawnCenter);

async function pasteFromURI(URI) {
    var img = new Image;
    img.crossOrigin = "Anonymous";
    img.src = URI;
    await img.decode();
    previewFB.ctx.drawImage(img, 0, 0); 
    const imData = previewFB.ctx.getImageData(0, 0, previewSize, previewSize);
    const imDataPNGView = new PNGView(imData.data.buffer);
    const c = deserialize(imDataPNGView);
    return c;
}

async function pasteFromFile(dataTransferFile) {
    let result = await asyncReadAsDataURL(dataTransferFile);
    let c = await pasteFromURI(result);
    return c;
}

function failureToRead(msg){
    //TODO add a message if we fail to load the image.
    if (msg == undefined){
        msg = "internal error!"
    }
    //TODO: show this to user
    console.log(msg);
    return;
}

// TODO:
// paste function handle everything - DONE
// user error message
// upload to zoo button
// add names - DONE
// add name editing function
// use localstorage - DONE
async function handlePasteOrDrop(incomingData, x, y) {

    parsePromises = []

    for (let i = 0; i < incomingData.types.length; i++) {
        try {
            if (incomingData.types[i] == "Files") {
                for (let j = 0; j < incomingData.files.length; j++) {
                    parsePromises.push(pasteFromFile(incomingData.files[j]));
                }
            } else if (incomingData.types[i] == "text/uri-list"){
                parsePromises.push(pasteFromURI(incomingData.getData('URL'))); // 'text/uri-list' returns multiple urls, 'URL' returns first valid one.
            } else if (incomingData.types[i] == "text/html"){
                const parser = new DOMParser().parseFromString(incomingData.getData("text/html"), "text/html");
                const imgSrc = parser.documentElement.querySelector("img")?.src;
                parsePromises.push(pasteFromURI(imgSrc));
            } else if (incomingData.types[i] == "application/json"){
                // TODO(DONE) json paste
                // in reality we'll probably not (never?) an "application/json" unless we have our own application supply this format.
                let jc = JSON.parse(incomingData.getData("application/json"))
                parsePromises.push(Promise.resolve(jc))
            }
        } catch (e) {
            console.log(`format string {incomingData.types[i]} failed with exception {e}`);
        }
    }

    // handle promises after collecting all of them. if we `await` in loop, we lose the eventData as drop event ends.
    try {
        const c = await Promise.any(parsePromises);
        console.log("picked up creature!", c.name);
        pasteCreature(c, x, y);
    } catch (e) {
        failureToRead("unreadable file! your creature may be corrupted.")
        console.log(e);
    }
}


canvas.ondragenter = canvas.ondragover = e=>e.preventDefault();
canvas.ondrop = async (e) =>{
    e.preventDefault();
    const [x, y] = event2wld([e.offsetX, e.offsetY]);
    
    // Check if shift key is held - if so, load as resource image instead of creature
    if (e.shiftKey) {
        // Load as resource image
        try {
            for (let i = 0; i < e.dataTransfer.files.length; i++) {
                const file = e.dataTransfer.files[i];
                if (file.type.startsWith('image/')) {
                    const dataUrl = await asyncReadAsDataURL(file);
                    await lenia.loadResourceImage(dataUrl);
                    console.log('Loaded resource image:', file.name);
                    return;
                }
            }
            // Try URL
            const url = e.dataTransfer.getData('URL');
            if (url) {
                await lenia.loadResourceImage(url);
                console.log('Loaded resource image from URL');
                return;
            }
        } catch (err) {
            console.log('Failed to load as resource:', err);
        }
    } else {
        // Try to load as creature first
        await handlePasteOrDrop(e.dataTransfer, x, y);
    }
    return;
}

window.addEventListener('paste', async (e) => {
    e.preventDefault();
    await handlePasteOrDrop(e.clipboardData, 0, 0);
    return;

});

// Disable intro overlays - set seenIntro to skip the tutorial
localStorage["seenIntro"] = true;
document.querySelectorAll(".canvasOverlay").forEach((telem) => {
    telem.style["pointer-events"] = "none";
    telem.style["transition"] = "none";
    telem.style["opacity"] = "0.0";
});

// resetvi element removed - intro disabled
if ($("#resetvi")) {
    $("#resetvi").onclick = () => {
        localStorage.removeItem("seenIntro");
        $("#touch").style.opacity = "1.0";
        $("#touch").style["pointer-events"] = "auto";
    };
}

// add a "upload creature" special entry
var uploadInput = document.createElement('input');
uploadInput.type = 'file';
uploadButton = document.createElement('div'); uploadButton.className = "previewContainer"; uploadButton.id = "uploadButton";
uploadButton.innerHTML = "<span id='pluspan'>+</span>";
$('#zoo').appendChild(uploadButton);
uploadButton.onclick = (e) => {
    uploadInput.click();
}
uploadInput.addEventListener("change", async (e) => {
    console.log(uploadInput.files);
    let c = await pasteFromFile(uploadInput.files[0]);
    console.log("picked up creature!", c.name);
    try {
        pasteCreature(c, 0.0, 0.0, 1.0);
        captureCreature(false, c, undefined, undefined, true);
        lenia.clearSelection();
    } catch (e) {
        console.log("failed?");
        console.log(e);
    }
}, false);

    // Expose previewFB and previewSize globally
    window.previewFB = previewFB;
    window.previewSize = previewSize;
    window.pasteCreature = pasteCreature;
    window.captureCreature = captureCreature;

    // Start animation loop
    requestAnimationFrame(animate);
})();  // Close async init function
</script>
