<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Lennings - Play Mode</title>

<script src="twgl.min.js"></script>
<script src="zoo.js"></script>
<script src="serialize.js"></script>
<script src="PNGView.js"></script>
<script src="lenia.js?v=33"></script>
<script src="game-engine.js"></script>
<script src="names.js"></script>

<style>
    * {
        box-sizing: border-box;
    }
    
    /* Console / GBG practice-style dark theme */
    :root {
        --bg: #1e1e1e;
        --panel: #252526;
        --border: #2d2d2d;
        --text: #d4d4d4;
        --muted: #9aa0a6;
        --accent-blue: #569cd6;
        --accent-purple: #c586c0;
        --accent-cyan: #4fc1ff;
        --success: #89d185;
        --warn: #dcdcaa;
        --error: #f48771;
        /* Survival-flavored override (slightly warmer) */
        --survival-bg: #1f1a18;
        --survival-panel: #2a2523;
        --survival-border: #3a322f;
        --survival-accent: #c9785f;
        --survival-text: #e8d4c8;
    }
    
    body { 
        font-family: Consolas, SFMono-Regular, Menlo, Monaco, monospace;
        margin: 0; 
        padding: 0;
        overflow: hidden;
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        background: var(--survival-bg);
        color: var(--survival-text);
    }

    #container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        touch-action: none;
    }
    
    #c {
        width: 100vw; 
        height: 100vh; 
        display: block;
        touch-action: none;
    }

    /* Level Selection Screen */
    #levelSelect {
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at top, #2b2522 0%, var(--survival-bg) 55%, #120f0e 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        padding: 20px;
    }

    #levelSelect.hidden {
        display: none;
    }

    #levelSelect h1 {
        font-size: 3rem;
        margin-bottom: 0.5rem;
        background: linear-gradient(90deg, #4af2a1, #6af);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    #levelSelect .subtitle {
        font-size: 1.1rem;
        color: var(--muted);
        margin-bottom: 2rem;
    }

    .start-btn {
        padding: 16px 48px;
        font-size: 1.3rem;
        font-weight: bold;
        background: linear-gradient(135deg, var(--survival-accent) 0%, var(--accent-purple) 100%);
        border: 1px solid var(--border);
        border-radius: 8px;
        color: #0b0b0b;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-top: 1rem;
    }

    .start-btn:hover {
        transform: scale(1.03);
        box-shadow: 0 0 24px rgba(201, 120, 95, 0.5);
    }

    /* Game HUD */
    #gameHUD {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        padding: 12px 24px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        z-index: 50;
        pointer-events: none;
    }

    #gameHUD.hidden {
        display: none;
    }

    #gameHUD > * {
        pointer-events: auto;
    }

    .hud-left {
        display: flex;
        align-items: center;
        gap: 16px;
    }

    .hud-right {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
    }

    .level-info {
        font-size: 1.1rem;
    }

    .level-info .level-label {
        color: #888;
        font-size: 0.8rem;
    }

    /* Stats display */
    .stats {
        display: flex;
        gap: 20px;
        font-size: 0.9rem;
    }

    .stat {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .stat-value {
        font-size: 1.2rem;
        font-weight: bold;
        color: #fff;
    }

    .stat-label {
        font-size: 0.7rem;
        color: #888;
        text-transform: uppercase;
    }

    /* Menu button */
    .menu-btn {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        padding: 8px 16px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s ease;
    }

    .menu-btn:hover {
        background: #33302d;
    }

    /* Skills bar: help + R, W, D */
    .skills-bar {
        position: fixed;
        left: 20px;
        bottom: 24px;
        display: flex;
        gap: 10px;
        z-index: 60;
        pointer-events: auto;
    }

    .skills-bar.hidden {
        display: none;
    }

    .skill-btn {
        min-width: 70px;
        min-height: 52px;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
        transition: border-color 0.2s, background 0.2s;
        position: relative;
        overflow: visible;
    }

    .skill-btn:hover:not(.on-cooldown) {
        border-color: var(--accent-blue);
        background: #33302d;
    }

    .skill-btn:active:not(.on-cooldown) {
        transform: scale(0.97);
    }

    .skill-btn.on-cooldown {
        cursor: not-allowed;
        opacity: 0.7;
    }

    .skill-btn .skill-key {
        font-size: 1.1rem;
        font-weight: bold;
        font-family: Consolas, SFMono-Regular, Menlo, Monaco, monospace;
        color: var(--accent-cyan);
    }

    .skill-btn .skill-label {
        font-size: 0.7rem;
        color: var(--muted);
        margin-top: 2px;
    }

    .skill-cooldown {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 0%;
        background: linear-gradient(180deg, rgba(45, 35, 50, 0.95) 0%, rgba(60, 32, 40, 0.95) 100%);
        border-top: 1px solid rgba(255, 100, 150, 0.5);
        transition: height 0.1s linear;
        pointer-events: none;
    }

    .skill-btn.on-cooldown .skill-cooldown {
        box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.5);
    }

    /* Speed burst: obvious active state */
    .skill-btn.active-burst {
        border-color: #ffd93d;
        background: rgba(40, 35, 0, 0.85);
        box-shadow: 0 0 20px rgba(255, 217, 61, 0.6), inset 0 0 15px rgba(255, 217, 61, 0.15);
        animation: burst-glow 0.8s ease-in-out infinite;
    }

    .skill-btn.active-burst .skill-key {
        color: #ffd93d;
        text-shadow: 0 0 10px rgba(255, 217, 61, 0.9);
    }

    .skill-btn.active-burst .skill-label {
        color: #ffd93d;
    }

    .help-btn {
        width: 48px;
        height: 48px;
        min-width: 48px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.35);
        background: rgba(0, 0, 0, 0.7);
        color: #aaa;
        font-size: 1.4rem;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s, border-color 0.2s, background 0.2s;
    }
    .help-btn:hover {
        color: var(--accent-cyan);
        border-color: var(--accent-blue);
        background: #33302d;
    }

    @keyframes burst-glow {
        0%, 100% { box-shadow: 0 0 20px rgba(255, 217, 61, 0.6), inset 0 0 15px rgba(255, 217, 61, 0.15); }
        50% { box-shadow: 0 0 28px rgba(255, 217, 61, 0.9), inset 0 0 20px rgba(255, 217, 61, 0.25); }
    }

    .snapshot-inventory {
        position: fixed;
        right: 20px;
        top: 80px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        z-index: 50;
    }

    .snapshot-charges {
        display: flex;
        align-items: center;
        gap: 8px;
        background: var(--panel);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 0.85rem;
        border: 1px solid var(--border);
    }
    
    .snapshot-charges .charge-label {
        color: var(--muted);
    }
    
    .snapshot-charges .charge-dots {
        display: flex;
        gap: 4px;
    }

    .snapshot-charges .charge-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--border);
        transition: all 0.3s ease;
    }
    
    .snapshot-charges .charge-dot.available {
        background: var(--success);
        border-color: var(--success);
        box-shadow: 0 0 8px rgba(137, 209, 133, 0.5);
    }
    
    .snapshot-charges .key-hint {
        color: var(--muted);
        font-size: 0.75rem;
        margin-left: 8px;
    }

    .snapshot-charges kbd {
        background: rgba(255, 255, 255, 0.1);
        padding: 2px 6px;
        border-radius: 3px;
        font-family: monospace;
    }

    /* When snapshot-charges is used inside a skill button, render it as a
       small overlay strip above the button content. */
    .skill-btn .snapshot-charges {
        position: absolute;
        top: -8px;
        left: 50%;
        transform: translateX(-50%);
        background: transparent;
        border: none;
        padding: 0;
        font-size: 0; /* hide any label text if present */
    }
    
    .skill-btn .snapshot-charges .charge-dots {
        gap: 3px;
    }
    
    .skill-btn .snapshot-charges .charge-dot {
        width: 12px;
        height: 12px;
        box-shadow: none;
    }

    .snapshot-slot {
        width: 100px;
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        overflow: hidden;
        transition: all 0.3s ease;
        margin-bottom: 8px;
    }

    .snapshot-slot.filled {
        border-color: rgba(74, 242, 161, 0.3);
    }

    .snapshot-slot.winner {
        border-color: #4af2a1;
        box-shadow: 0 0 15px rgba(74, 242, 161, 0.4);
    }

    .snapshot-slot .snapshot-image {
        width: 100%;
        aspect-ratio: 1;
        object-fit: cover;
        display: block;
    }

    .snapshot-slot .snapshot-info {
        padding: 6px;
        text-align: center;
        font-size: 0.75rem;
    }

    .snapshot-slot .snapshot-ssim {
        color: #4af2a1;
        font-weight: bold;
        font-family: monospace;
    }

    .snapshot-slot .snapshot-ssim.low {
        color: #ff6b6b;
    }

    .snapshot-slot .snapshot-ssim.medium {
        color: #ffd93d;
    }

    .snapshot-slot .snapshot-ssim.high {
        color: #4af2a1;
    }

    .eaten-rings-container {
        width: 100px;
        height: 100px;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: visible;
    }

    .hud-circle {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
    }
    
    .eaten-rings-container {
        width: 140px;
        height: 140px;
        border-radius: 50%;
        border: 2px solid var(--border);
        padding: 10px;
        background: radial-gradient(circle at top, rgba(255,255,255,0.05), transparent);
        box-shadow: 0 0 20px rgba(0,0,0,0.6);
    }
    
    .eaten-rings-canvas {
        width: 100%;
        height: 100%;
        display: block;
    }
    
    .hud-circle-stats {
        display: flex;
        gap: 24px;
        margin-top: 4px;
    }

    .hud-circle-eaten {
        margin-top: 2px;
    }
    
    .hud-circle-eaten .eaten-label {
        font-size: 0.7rem;
        letter-spacing: 0.08em;
        color: var(--muted);
        text-transform: uppercase;
        text-align: center;
    }
    
    .hud-circle-eaten .eaten-count {
        font-size: 0.8rem;
        color: var(--text);
        font-family: Consolas, SFMono-Regular, Menlo, Monaco, monospace;
        text-align: center;
    }

    /* Mobile layout: right HUD top-right, ? at mid-y left, title top-left */
    @media (max-width: 768px) {
        #gameHUD {
            padding: 8px 12px;
            flex-direction: row;
            justify-content: space-between;
            align-items: flex-start;
        }
        /* Top-left: only level title (no ? here) */
        .hud-left {
            justify-content: flex-start;
            align-items: flex-start;
        }
        /* ? button: fixed at mid-y on the left to use space better */
        .hud-left .help-btn {
            position: fixed;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 60;
        }
        /* Right HUD: fixed top-right so circle + reconstructions don't block the game */
        .hud-right {
            position: fixed;
            top: 8px;
            right: 8px;
            left: auto;
            align-items: flex-end;
            gap: 6px;
        }
        .eaten-rings-container {
            width: 100px;
            height: 100px;
        }
        .hud-circle-stats {
            gap: 16px;
        }
        #snapshotSlots {
            width: 100px;
        }
        .skills-bar {
            left: 0;
            right: 0;
            bottom: 8px;
            justify-content: space-evenly;
            padding: 0 8px;
        }
        .skill-btn {
            min-width: 56px;
            min-height: 44px;
        }
    }

    #snapshotSlots {
        width: 140px; /* match circle container width */
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 4px;
    }

    /* Snapshot Animation Overlay */
    #snapshotOverlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 300;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }

    #snapshotOverlay.visible {
        opacity: 1;
        pointer-events: auto;
    }

    #snapshotOverlay .snapshot-title {
        font-size: 1.5rem;
        color: #4af2a1;
        margin-bottom: 20px;
    }

    /* Loading state */
    #snapshotOverlay .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
    }

    #snapshotOverlay .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid rgba(255, 255, 255, 0.1);
        border-top-color: #4af2a1;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    #snapshotOverlay .loading-text {
        font-size: 1rem;
        color: #888;
    }

    #snapshotOverlay .loading-pixels {
        font-size: 0.85rem;
        color: #4af2a1;
        font-family: monospace;
    }

    #snapshotOverlay .loading-container.hidden {
        display: none;
    }

    #snapshotOverlay .snapshot-canvas-container.hidden {
        display: none;
    }

    #snapshotOverlay .snapshot-canvas-container {
        position: relative;
        width: 400px;
        height: 400px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        overflow: hidden;
        background: #000;
    }

    #snapshotOverlay #snapshotCanvas {
        width: 100%;
        height: 100%;
    }

    #snapshotOverlay .snapshot-result {
        margin-top: 20px;
        text-align: center;
        opacity: 0;
        transition: opacity 0.5s ease;
    }

    #snapshotOverlay .snapshot-result.visible {
        opacity: 1;
    }

    #snapshotOverlay .snapshot-result .ssim-big {
        font-size: 3rem;
        font-weight: bold;
        font-family: monospace;
    }

    #snapshotOverlay .snapshot-result .ssim-label {
        font-size: 1rem;
        color: #888;
        margin-top: 8px;
    }

    #snapshotOverlay .snapshot-result .result-message {
        font-size: 1.2rem;
        margin-top: 16px;
    }

    #snapshotOverlay .snapshot-result .result-message.success {
        color: #4af2a1;
    }

    #snapshotOverlay .snapshot-result .result-message.continue {
        color: #ffd93d;
    }

    #snapshotOverlay .snapshot-result .result-message.motif-failed {
        color: #ff8c42;
        font-weight: bold;
    }

    #snapshotOverlay .snapshot-result .result-btn {
        margin-top: 20px;
        padding: 12px 24px;
        font-size: 1.1rem;
        font-weight: bold;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    #snapshotOverlay .snapshot-result .result-btn:hover {
        transform: scale(1.05);
    }

    #snapshotOverlay .snapshot-result .result-btn.hidden {
        display: none;
    }

    #snapshotOverlay .snapshot-result .result-btn-fail {
        background: #c62828;
        color: #fff;
        box-shadow: 0 0 20px rgba(198, 40, 40, 0.5);
    }

    #snapshotOverlay .snapshot-result .result-btn-fail:hover {
        box-shadow: 0 0 28px rgba(198, 40, 40, 0.7);
    }

    /* Win Overlay */
    #winOverlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 200;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease;
    }

    #winOverlay.visible {
        opacity: 1;
        pointer-events: auto;
    }

    #winOverlay h2 {
        font-size: 3rem;
        margin-bottom: 1rem;
        color: #4af2a1;
        text-shadow: 0 0 30px rgba(74, 242, 161, 0.5);
    }

    #winOverlay .win-stats {
        display: flex;
        gap: 40px;
        margin-bottom: 2rem;
    }

    #winOverlay .win-stat {
        text-align: center;
    }

    #winOverlay .win-stat-value {
        font-size: 2rem;
        font-weight: bold;
        color: #fff;
    }

    #winOverlay .win-stat-label {
        font-size: 0.9rem;
        color: #888;
    }

    .win-buttons {
        display: flex;
        gap: 16px;
    }

    .win-btn {
        background: linear-gradient(135deg, #4af2a1, #3ad991);
        border: none;
        border-radius: 8px;
        color: #000;
        padding: 14px 32px;
        cursor: pointer;
        font-size: 1.1rem;
        font-weight: bold;
        transition: all 0.2s ease;
    }

    .win-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(74, 242, 161, 0.4);
    }

    /* Win reconstruction preview */
    .win-preview {
        margin-bottom: 1.5rem;
        text-align: center;
    }

    .win-preview img {
        max-width: 200px;
        max-height: 200px;
        border: 3px solid #4af2a1;
        border-radius: 8px;
        box-shadow: 0 0 30px rgba(74, 242, 161, 0.3);
    }

    .win-preview .preview-label {
        font-size: 0.9rem;
        color: #888;
        margin-top: 8px;
    }

    /* Gallery Overlay */
    #galleryOverlay {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
        z-index: 250;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 40px 20px;
        overflow-y: auto;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }

    #galleryOverlay.visible {
        opacity: 1;
        pointer-events: auto;
    }

    #galleryOverlay h2 {
        font-size: 2.5rem;
        margin-bottom: 0.5rem;
        background: linear-gradient(90deg, #4af2a1, #6af);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    #galleryOverlay .gallery-subtitle {
        color: #888;
        margin-bottom: 2rem;
        font-size: 1.1rem;
    }

    .gallery-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 20px;
        max-width: 900px;
        width: 100%;
        margin-bottom: 2rem;
    }

    .gallery-item {
        background: rgba(255, 255, 255, 0.05);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        overflow: hidden;
        transition: all 0.3s ease;
    }

    .gallery-item:hover {
        border-color: rgba(74, 242, 161, 0.4);
        transform: translateY(-4px);
    }

    .gallery-item.new {
        border-color: #4af2a1;
        box-shadow: 0 0 20px rgba(74, 242, 161, 0.3);
        animation: newItemPulse 2s ease-out;
    }

    @keyframes newItemPulse {
        0% { box-shadow: 0 0 40px rgba(74, 242, 161, 0.6); }
        100% { box-shadow: 0 0 20px rgba(74, 242, 161, 0.3); }
    }

    .gallery-item img {
        width: 100%;
        aspect-ratio: 1;
        object-fit: cover;
        display: block;
    }

    .gallery-item-info {
        padding: 12px;
        text-align: center;
    }

    .gallery-item-name {
        font-size: 0.95rem;
        font-weight: bold;
        margin-bottom: 4px;
        color: #fff;
    }

    .gallery-item-ssim {
        font-size: 0.85rem;
        font-family: monospace;
        color: #4af2a1;
    }

    .gallery-item-time {
        font-size: 0.75rem;
        color: #666;
        margin-top: 4px;
    }

    .gallery-empty {
        text-align: center;
        color: #666;
        padding: 60px 20px;
        font-size: 1.1rem;
    }

    .gallery-buttons {
        display: flex;
        gap: 16px;
        margin-top: auto;
        padding-top: 20px;
    }

    .gallery-btn {
        background: linear-gradient(135deg, #4af2a1, #3ad991);
        border: none;
        border-radius: 8px;
        color: #000;
        padding: 14px 32px;
        cursor: pointer;
        font-size: 1.1rem;
        font-weight: bold;
        transition: all 0.2s ease;
    }

    .gallery-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(74, 242, 161, 0.4);
    }

    .gallery-btn.secondary {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
    }

    .gallery-btn.secondary:hover {
        background: rgba(255, 255, 255, 0.2);
        box-shadow: none;
    }

    /* Collection counter in HUD */
    .collection-counter {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(0, 0, 0, 0.5);
        padding: 6px 12px;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .collection-counter:hover {
        background: rgba(74, 242, 161, 0.2);
    }

    .collection-counter .icon {
        font-size: 1.2rem;
    }

    .collection-counter .count {
        font-weight: bold;
        color: #4af2a1;
    }

    .win-btn.secondary {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
    }

    .win-btn.secondary:hover {
        background: rgba(255, 255, 255, 0.2);
        box-shadow: none;
    }

    /* (short bottom instructions hint removed as redundant) */

    /* Pause overlay */
    #pauseOverlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 150;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }

    #pauseOverlay.visible {
        opacity: 1;
        pointer-events: auto;
    }

    #pauseOverlay h2 {
        font-size: 3rem;
        color: #fff;
    }

    .help-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        z-index: 250;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    .help-overlay.visible {
        opacity: 1;
        pointer-events: auto;
    }
    .help-overlay .help-content {
        max-width: 480px;
        max-height: 85vh;
        overflow-y: auto;
        background: rgba(20, 20, 28, 0.98);
        border: 1px solid rgba(74, 242, 161, 0.25);
        border-radius: 12px;
        padding: 24px;
        color: #e0e0e0;
    }
    .help-overlay .help-content h2 {
        margin-top: 0;
        color: #4af2a1;
        font-size: 1.5rem;
    }
    .help-overlay .help-content p, .help-overlay .help-content ul {
        margin: 0.75rem 0;
        font-size: 0.95rem;
        line-height: 1.5;
    }
    .help-overlay .help-content ul {
        padding-left: 1.25rem;
    }
    .help-overlay .help-content li {
        margin: 0.4rem 0;
    }
    .help-overlay .help-content kbd {
        background: rgba(255, 255, 255, 0.12);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: inherit;
    }
    .help-overlay .help-close-btn {
        margin-top: 1rem;
        padding: 10px 24px;
        font-size: 1rem;
        background: #4af2a1;
        color: #000;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: transform 0.15s, box-shadow 0.15s;
    }
    .help-overlay .help-close-btn:hover {
        transform: scale(1.03);
        box-shadow: 0 0 16px rgba(74, 242, 161, 0.5);
    }
</style>

<div id="container">
    <canvas id="c" width="800" height="800"></canvas>
</div>

<!-- Level Selection Screen -->
<div id="levelSelect">
    <h1>Lennings</h1>
    <p class="subtitle">Reconstruct the image by growing your particles</p>
    <p class="subtitle" style="font-size: 0.9rem; color: #666; margin-top: -1rem;">
        Press <kbd style="background: rgba(255,255,255,0.1); padding: 2px 8px; border-radius: 4px;">D</kbd> to digest pixels and reconstruct the image
    </p>
    <button class="start-btn" id="startGameBtn">Start Game</button>
    <button class="start-btn secondary" id="viewCollectionStartBtn" style="background: rgba(255,255,255,0.1); color: #fff; margin-top: 12px; font-size: 1rem; padding: 12px 32px;">
        üñºÔ∏è View Collection (<span id="startCollectionCount">0</span>)
    </button>
</div>

<!-- Game HUD -->
<div id="gameHUD" class="hidden">
    <div class="hud-left">
        <button type="button" class="help-btn" id="helpBtn" title="How to play">?</button>
        <div class="level-info">
            <div class="level-label">LEVEL</div>
            <div id="levelName">-</div>
        </div>
    </div>
    
    <div class="hud-right">
        <div class="hud-circle">
            <div class="eaten-rings-container" id="eatenRingsContainer" title="Color mass: average color, size = eaten / image pixels">
                <canvas id="eatenRingsCanvas" width="120" height="120" class="eaten-rings-canvas"></canvas>
            </div>
            <div class="hud-circle-eaten">
                <div class="eaten-label">EATEN PIXELS</div>
                <div class="eaten-count" id="eatenPixelsCount">0</div>
            </div>
            <div class="hud-circle-stats">
                <div class="stat">
                    <div class="stat-value" id="cellCount">0</div>
                    <div class="stat-label">Cells</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="timeDisplay">0:00</div>
                    <div class="stat-label">Time</div>
                </div>
            </div>
        </div>
        <div id="snapshotSlots"></div>
    </div>
</div>

<!-- Skills (Q, W, E, D, R) -->
<div id="skillsBar" class="skills-bar hidden">
    <div class="skill-btn" id="skillQ" data-key="q" title="Split: trigger reproduction for ready cells (cooldown)">
        <span class="skill-key">Q</span>
        <span class="skill-label">Split</span>
        <div class="skill-cooldown" id="cooldownQ"></div>
    </div>
    <div class="skill-btn" id="skillW" data-key="w" title="Speed burst: 5s faster + attraction (25s cooldown)">
        <span class="skill-key">W</span>
        <span class="skill-label">Burst</span>
        <div class="skill-cooldown" id="cooldownW"></div>
    </div>
    <div class="skill-btn" id="skillE" data-key="e" title="Evolve: adapt colors to environment (cooldown)">
        <span class="skill-key">E</span>
        <span class="skill-label">Evolve</span>
        <div class="skill-cooldown" id="cooldownE"></div>
    </div>
    <div class="skill-btn" id="skillD" data-key="d" title="Digest: reconstruct from eaten pixels (3 per level)">
        <div class="snapshot-charges" data-skill="d">
            <div class="charge-dots" id="charges-d"></div>
        </div>
        <span class="skill-key">D</span>
        <span class="skill-label">Digest</span>
    </div>
    <div class="skill-btn" id="skillR" data-key="r" title="Respawn: new random location (15s cooldown)">
        <span class="skill-key">R</span>
        <span class="skill-label">Respawn</span>
        <div class="skill-cooldown" id="cooldownR"></div>
    </div>
</div>

<!-- (snapshotInventory panel removed; reconstructions now live under HUD circle) -->

<!-- Digest overlay (loading ‚Üí animation ‚Üí result) -->
<div id="snapshotOverlay">
    <div class="snapshot-title" id="snapshotTitle">Digesting...</div>
    
    <!-- Loading state -->
    <div class="loading-container" id="loadingContainer">
        <div class="loading-spinner"></div>
        <div class="loading-text">Processing pixels...</div>
        <div class="loading-pixels" id="loadingPixels">0 pixels</div>
    </div>
    
    <!-- Animation canvas -->
    <div class="snapshot-canvas-container hidden" id="canvasContainer">
        <canvas id="snapshotCanvas" width="400" height="400"></canvas>
    </div>
    
    <div class="snapshot-result" id="snapshotResult">
        <div class="ssim-big" id="snapshotSSIM">0.000</div>
        <div class="ssim-label">SSIM Score</div>
        <div class="result-message" id="resultMessage"></div>
        <button type="button" class="result-btn hidden" id="continueBtn">Back to level</button>
        <button type="button" class="result-btn result-btn-fail hidden" id="nextMotifBtn">Next motif ‚Üí</button>
    </div>
</div>

<!-- Win Overlay -->
<div id="winOverlay">
    <h2>Level Complete!</h2>
    <div class="win-preview">
        <img id="winPreviewImg" src="" alt="Your reconstruction">
        <div class="preview-label">Added to your collection!</div>
    </div>
    <div class="win-stats">
        <div class="win-stat">
            <div class="win-stat-value" id="winSSIM">-</div>
            <div class="win-stat-label">SSIM Score</div>
        </div>
        <div class="win-stat">
            <div class="win-stat-value" id="winTime">-</div>
            <div class="win-stat-label">Time</div>
        </div>
        <div class="win-stat">
            <div class="win-stat-value" id="winCells">-</div>
            <div class="win-stat-label">Cells</div>
        </div>
    </div>
    <div class="win-buttons">
        <button class="win-btn" id="nextLevelBtn">Next Level ‚Üí</button>
        <button class="win-btn secondary" id="viewCollectionBtn">View Collection</button>
        <button class="win-btn secondary" id="menuBtn">Menu</button>
    </div>
</div>

<!-- Gallery Overlay -->
<div id="galleryOverlay">
    <h2>Your Collection</h2>
    <p class="gallery-subtitle">Reconstructions you've created</p>
    <div class="gallery-grid" id="galleryGrid">
        <!-- Items populated by JavaScript -->
    </div>
    <div class="gallery-empty" id="galleryEmpty">
        No reconstructions yet. Play some levels to build your collection!
    </div>
    <div class="gallery-buttons">
        <button class="gallery-btn" id="galleryContinueBtn">Continue Playing ‚Üí</button>
        <button class="gallery-btn secondary" id="galleryBackBtn">Back</button>
    </div>
</div>

<!-- Pause Overlay -->
<div id="pauseOverlay">
    <h2>PAUSED</h2>
</div>

<!-- Help Overlay -->
<div id="helpOverlay" class="help-overlay">
    <div class="help-content">
        <h2>How to Play</h2>
        <p><strong>Goal:</strong> Your creatures eat pixels from the environment. Reconstruct the motif image by digesting at the right time. Reach the SSIM score target (e.g. 0.7) to complete the level.</p>
        <p><strong>Controls:</strong></p>
        <ul>
            <li><kbd>Q</kbd> <strong>Split</strong> ‚Äî Trigger reproduction for all \"pregnant\" cells (energy above threshold).</li>
            <li><kbd>W</kbd> <strong>Burst</strong> ‚Äî Short speed and attraction boost.</li>
            <li><kbd>E</kbd> <strong>Evolve</strong> ‚Äî Let creatures adapt their colors toward the environment.</li>
            <li><kbd>D</kbd> <strong>Digest</strong> ‚Äî Use eaten pixels to form one reconstruction. Each digest locks those pixels (they can‚Äôt be reused).</li>
            <li><kbd>R</kbd> <strong>Respawn</strong> ‚Äî New random spawn and colors. Does <em>not</em> restore digests or eaten pixels.</li>
            <li><kbd>Space</kbd> Pause / resume</li>
        </ul>
        <p><strong>UI:</strong> Top bar shows level name, cells, time, and the <em>eaten pixels</em> circle with its counter. Reconstructions you keep appear as small cards under the circle.</p>
        <p>Win by getting one digest with SSIM ‚â• target. If you use all digests without reaching it, the motif fails and you can load the next one.</p>
        <button type="button" class="help-close-btn" id="helpCloseBtn">Got it</button>
    </div>
</div>

<script>
const $ = s => document.querySelector(s);
const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl2', {alpha: false});
gl.getExtension("EXT_color_buffer_float");
gl.getExtension("OES_texture_float_linear");

// Helper function similar to main app
function calcNormCoef(m, s) {
    const dr = 0.1 * s;
    let acc = 0.0, prev = null;
    for (let r = Math.max(m - s * 3.0, 0.0); r < m + s * 3.0; r += dr) {
        let y = (r - m) / s;
        let v = r * Math.exp(-y * y);
        if (prev != null) acc += (prev + v) * 0.5;
        prev = v;
    }
    return 1.0 / (acc * dr * 2.0 * Math.PI);
}

// Global state
let lenia = null;
let params = null;
let gameEngine = null;

// Helper to get param value from JSON
function getParamValue(paramMap, paramName, defaultValue) {
    const param = paramMap[paramName];
    if (param && param.value !== undefined) {
        return param.value;
    }
    return defaultValue;
}

// UI Elements
const levelSelectEl = $('#levelSelect');
const gameHUDEl = $('#gameHUD');
const winOverlayEl = $('#winOverlay');
const pauseOverlayEl = $('#pauseOverlay');
const instructionsEl = null;
const galleryOverlayEl = $('#galleryOverlay');

// Collection system - stores all winning reconstructions
let collection = [];
let latestWinData = null; // Stores data for the most recent win

function addToCollection(levelName, ssim, time, imageDataURL) {
    const item = {
        id: `recon-${Date.now()}`,
        levelName,
        ssim,
        time,
        imageDataURL,
        timestamp: Date.now()
    };
    collection.push(item);
    updateCollectionCounter();
    saveCollection();
    return item;
}

function updateCollectionCounter() {
    const hudCount = $('#collectionCount');
    if (hudCount) hudCount.textContent = collection.length;
    // Also update start screen counter
    const startCount = $('#startCollectionCount');
    if (startCount) startCount.textContent = collection.length;
}

function saveCollection() {
    // Save to localStorage for persistence
    try {
        localStorage.setItem('lennings_collection', JSON.stringify(collection));
    } catch (e) {
        console.warn('Could not save collection:', e);
    }
}

function loadCollection() {
    try {
        const saved = localStorage.getItem('lennings_collection');
        if (saved) {
            collection = JSON.parse(saved);
            updateCollectionCounter();
        }
    } catch (e) {
        console.warn('Could not load collection:', e);
        collection = [];
    }
}

function showGallery(highlightLatest = false) {
    const grid = $('#galleryGrid');
    const empty = $('#galleryEmpty');
    
    grid.innerHTML = '';
    
    if (collection.length === 0) {
        empty.style.display = 'block';
        grid.style.display = 'none';
    } else {
        empty.style.display = 'none';
        grid.style.display = 'grid';
        
        // Show newest first
        const sorted = [...collection].reverse();
        sorted.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = 'gallery-item' + (highlightLatest && index === 0 ? ' new' : '');
            
            const timeStr = formatTime(item.time);
            div.innerHTML = `
                <img src="${item.imageDataURL}" alt="${item.levelName}">
                <div class="gallery-item-info">
                    <div class="gallery-item-name">${item.levelName}</div>
                    <div class="gallery-item-ssim">SSIM: ${item.ssim.toFixed(3)}</div>
                    <div class="gallery-item-time">${timeStr}</div>
                </div>
            `;
            grid.appendChild(div);
        });
    }
    
    galleryOverlayEl.classList.add('visible');
}

function hideGallery() {
    galleryOverlayEl.classList.remove('visible');
}

function formatTime(ms) {
    const seconds = Math.floor(ms / 1000);
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Initialize game
async function initGame() {
    // Load parameters
    const response = await fetch('parameters.json');
    const config = await response.json();
    
    // Build paramMap
    const paramMap = {};
    for (const [category, catData] of Object.entries(config)) {
        if (category === 'description' || category === 'version') continue;
        if (catData.params) {
            for (const [paramName, paramData] of Object.entries(catData.params)) {
                paramMap[paramName] = paramData;
            }
        }
    }
    
    // Initialize params object
    params = {
        stepN: getParamValue(paramMap, 'stepN', 1),
        targetFPS: getParamValue(paramMap, 'targetFPS', 60),
        renderMode: 1,
        showCellGraph: false,
        showTrailsOverlay: true,
        spawnCount: getParamValue(paramMap, 'spawnCount', 3),
        spawnCenter: getParamValue(paramMap, 'spawnCenter', [0.0, 0.0]),
        viewCenter: [0.0, 0.0],
        viewExtent: getParamValue(paramMap, 'viewExtent', 50.0),
        mousePos: [-10000.0, 0.0],
        mouseDown: false,
        touchRadius: getParamValue(paramMap, 'touchRadius', 0.05),
        paused: false,
        shiftKey: false,
        pointAddI: 0,
        enableLifeCycle: getParamValue(paramMap, 'enableLifeCycle', true),
        enableDeaths: getParamValue(paramMap, 'enableDeaths', true),
        // Disable automatic reproduction; reproduction is now triggered manually
        // via the Q \"split\" skill with a cooldown.
        enableReproduction: false,
        consumeEnabled: getParamValue(paramMap, 'consumeEnabled', true),
        useCpuRepro: getParamValue(paramMap, 'useCpuRepro', true),
        maxChildrenPerParent: getParamValue(paramMap, 'maxChildrenPerParent', 2),
        reproInterval: getParamValue(paramMap, 'reproInterval', 85),
    };
    
    // Initialize Lenia
    lenia = new ParticleLenia(gl, null, paramMap);
    
    // Initialize game engine with Glass Bead Game level pack (manifest + images folder)
    gameEngine = new LenningsGameEngine({ levelPackPath: 'levels/GlassBeadGame' });
    await gameEngine.initialize();
    gameEngine.attachSimulation(lenia, params);
    
    // Set up event listeners
    setupGameEvents();
    
    // Set up start button
    $('#startGameBtn').addEventListener('click', startRandomGame);
    
    // Help (?)
    const helpOverlayEl = $('#helpOverlay');
    $('#helpBtn').addEventListener('click', () => helpOverlayEl.classList.add('visible'));
    $('#helpCloseBtn').addEventListener('click', () => helpOverlayEl.classList.remove('visible'));
    helpOverlayEl.addEventListener('click', (e) => { if (e.target === helpOverlayEl) helpOverlayEl.classList.remove('visible'); });
    
    // Set up collection button on start screen
    $('#viewCollectionStartBtn').addEventListener('click', () => {
        showGallery(false);
    });
    
    // Load saved collection
    loadCollection();
    
    // Start animation loop
    requestAnimationFrame(animate);
}

function startRandomGame() {
    levelSelectEl.classList.add('hidden');
    gameHUDEl.classList.remove('hidden');
    skillsBarEl.classList.remove('hidden');
    hideSnapshotOverlay();
    
    // Reset snapshot UI
    resetSnapshotUI();
    
    // Short bottom instructions hint removed as redundant.
    
    // Start a random level
    gameEngine.startRandomLevel();
}

function setupGameEvents() {
    // Game engine events
    gameEngine.on('stateChange', ({ state }) => {
        updateUIForState(state);
    });
    
    gameEngine.on('progress', ({ ssim, smoothedSSIM, threshold, progress, cellCount, elapsedTime }) => {
        updateProgress(ssim, smoothedSSIM, threshold, progress, cellCount, elapsedTime);
    });
    
    // Level-won events are now reflected via the snapshot overlay result UI,
    // so we avoid popping a separate win overlay to prevent flicker.
    gameEngine.on('levelWon', ({ ssim, elapsedTime, cellCount, levelIndex }) => {
        // Optionally, we could log or store this, but UI is handled in snapshotResult.
        latestWinData = { ssim, elapsedTime, cellCount, levelIndex, imageDataURL: null };
    });
    
    gameEngine.on('levelStart', ({ level }) => {
        $('#levelName').textContent = level.name;
        // Hide pause overlay on level start/restart
        pauseOverlayEl.classList.remove('visible');
        // Hide win overlay on restart
        winOverlayEl.classList.remove('visible');
        // Reset snapshot UI
        resetSnapshotUI();
        // Hide snapshot overlay
        hideSnapshotOverlay();
        // Reset camera to spawn point
        resetCameraToSpawn();
    });
    
    // Skill buttons (Q split, W burst, E evolve, D digest, R respawn) - mobile-friendly
    ['q', 'w', 'e', 'd', 'r'].forEach(key => {
        const btn = $(`#skill${key.toUpperCase()}`);
        const cooldownEl = $(`#cooldown${key.toUpperCase()}`);
        if (!btn) return;
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            if (!gameEngine.isPlayMode() || gameEngine.gameState === 'won') return;
            if (key === 'r') {
                if (gameEngine.triggerSkill('r')) {
                    resetCameraToSpawn();
                }
            } else if (key === 'd') {
                if (gameEngine.canTakeDigest()) gameEngine.triggerSkill('d');
            } else if (key === 'w') {
                gameEngine.triggerSkill('w');
            } else if (key === 'q') {
                gameEngine.triggerSkill('q');
            } else if (key === 'e') {
                gameEngine.triggerSkill('e');
            }
        });
    });

    gameEngine.on('levelReset', () => {
        // Clean slate - hide all overlays and cancel animations
        hideSnapshotOverlay();
        pauseOverlayEl.classList.remove('visible');
        winOverlayEl.classList.remove('visible');
    });
    
    // Digest events
    gameEngine.on('digestStart', ({ chargesRemaining, pixelCount }) => {
        showSnapshotLoading(pixelCount);
    });
    gameEngine.on('digestAnimate', ({ digest, eatenPixels, reconstruction }) => {
        setTimeout(() => {
            playSnapshotAnimation(digest, eatenPixels, reconstruction);
        }, 300);
    });
    gameEngine.on('digestComplete', ({ digest, chargesRemaining, meetsThreshold }) => {
        addSnapshotToInventory(digest, meetsThreshold);
        updateChargeDisplay(chargesRemaining);
    });
    gameEngine.on('digestFailed', ({ reason }) => {
        hideSnapshotOverlay();
    });
    gameEngine.on('digestCancelled', () => {
        hideSnapshotOverlay();
    });
    gameEngine.on('skillCooldown', () => { /* UI updated in animate via tickSkillCooldowns */ });
    gameEngine.on('skillUsed', ({ key }) => {
        if (key === 'w') $('#skillW').classList.add('active-burst');
    });
    gameEngine.on('skillEnd', ({ key }) => {
        if (key === 'w') $('#skillW').classList.remove('active-burst');
    });
    
    // UI buttons
    $('#nextMotifBtn').addEventListener('click', () => {
        hideSnapshotOverlay();
        resetSnapshotUI();
        gameEngine.nextLevel();
    });

    $('#continueBtn').addEventListener('click', () => {
        hideSnapshotOverlay();
    });

    $('#nextLevelBtn').addEventListener('click', () => {
        winOverlayEl.classList.remove('visible');
        // Reset UI for new level
        resetSnapshotUI();
        // Load next random level
        gameEngine.nextLevel();
    });
    
    $('#viewCollectionBtn').addEventListener('click', () => {
        winOverlayEl.classList.remove('visible');
        showGallery(true); // Highlight the latest item
    });
    
    $('#menuBtn').addEventListener('click', () => {
        showLevelSelect();
    });
    
    // Gallery buttons
    $('#galleryContinueBtn').addEventListener('click', () => {
        hideGallery();
        // Reset UI for new level
        resetSnapshotUI();
        // Load next random level
        gameEngine.nextLevel();
    });
    
    $('#galleryBackBtn').addEventListener('click', () => {
        hideGallery();
        // Return to appropriate screen
        if (latestWinData) {
            // Came from win screen
            winOverlayEl.classList.add('visible');
        } else if (gameEngine.gameState === 'idle') {
            // Came from start screen - already there
        } else if (gameEngine.gameState === 'paused') {
            // Came from in-game, return to pause
            pauseOverlayEl.classList.add('visible');
        }
    });
    
    // Collection button in HUD (only if present)
    const collectionBtn = $('#collectionBtn');
    if (collectionBtn) {
        collectionBtn.addEventListener('click', () => {
            if (gameEngine.gameState === 'playing') {
                gameEngine.pause();
                pauseOverlayEl.classList.add('visible');
            }
            showGallery(false);
        });
    }
    
    // Keyboard controls
    window.addEventListener('keydown', handleKeyDown);
    
    // Mouse/touch controls for panning
    setupCanvasControls();
}

function handleKeyDown(e) {
    // Space - Pause/Resume (only during gameplay)
    if (e.key === ' ') {
        e.preventDefault();
        if (gameEngine.gameState === 'playing' || gameEngine.gameState === 'paused') {
            gameEngine.togglePause();
            pauseOverlayEl.classList.toggle('visible', gameEngine.gameState === 'paused');
        }
    }
    
    // R - Respawn at random location (skill with cooldown; does NOT reset digests)
    if (e.key === 'r' || e.key === 'R') {
        if (gameEngine.isPlayMode() && gameEngine.gameState !== 'won') {
            hideSnapshotOverlay();
            if (gameEngine.triggerSkill('r')) {
                resetCameraToSpawn();
            }
        }
    }
    
    // W - Speed burst (skill with cooldown)
    if (e.key === 'w' || e.key === 'W') {
        if (gameEngine.isPlayMode() && (gameEngine.gameState === 'playing' || gameEngine.gameState === 'paused')) {
            gameEngine.triggerSkill('w');
        }
    }

    // E - Evolve (adapt colors to environment, with cooldown)
    if (e.key === 'e' || e.key === 'E') {
        if (gameEngine.isPlayMode() && (gameEngine.gameState === 'playing' || gameEngine.gameState === 'paused')) {
            gameEngine.triggerSkill('e');
        }
    }

    // Q - Split (manual reproduction with cooldown)
    if (e.key === 'q' || e.key === 'Q') {
        if (gameEngine.isPlayMode() && (gameEngine.gameState === 'playing' || gameEngine.gameState === 'paused')) {
            gameEngine.triggerSkill('q');
        }
    }
    
    // D - Digest (reconstruct from eaten pixels; used pixels are marked digested)
    if (e.key === 'd' || e.key === 'D') {
        if (gameEngine.canTakeDigest()) {
            gameEngine.triggerSkill('d');
        }
    }
    
    // Escape - Go back to menu or close overlays
    if (e.key === 'Escape') {
        if (galleryOverlayEl.classList.contains('visible')) {
            hideGallery();
        } else if (gameEngine.gameState === 'won') {
            winOverlayEl.classList.remove('visible');
            showLevelSelect();
        } else {
            showLevelSelect();
        }
    }
    
    // Note: Render mode keys (1-4) and debug keys are intentionally disabled in play mode
}

// Auto-camera state for smooth following
let cameraState = {
    targetCenterX: 0,
    targetCenterY: 0,
    targetExtent: 50,
    currentCenterX: 0,
    currentCenterY: 0,
    currentExtent: 50,
    smoothing: 0.08,  // How quickly camera follows (0-1, lower = smoother)
    padding: 2.5,     // Padding multiplier around particles (higher = more zoomed out)
    minExtent: 20,    // Minimum zoom level
    maxExtent: 200,   // Maximum zoom level
    lastBoundsCheck: 0,
    boundsCheckInterval: 5  // Check bounds every N frames (GPU readback is expensive)
};

let cameraFrameCount = 0;

function updateAutoCamera() {
    if (!lenia) return;
    
    cameraFrameCount++;
    
    // Only check bounds periodically to avoid expensive GPU readbacks
    if (cameraFrameCount % cameraState.boundsCheckInterval === 0) {
        const bounds = lenia.getParticleBounds();
        if (bounds && bounds.count > 0) {
            // Calculate target view to frame all particles with padding
            const size = Math.max(bounds.width, bounds.height, 10); // Minimum size of 10
            cameraState.targetExtent = Math.min(
                cameraState.maxExtent,
                Math.max(cameraState.minExtent, size * cameraState.padding)
            );
            cameraState.targetCenterX = bounds.centerX;
            cameraState.targetCenterY = bounds.centerY;
        }
    }
    
    // Smooth interpolation towards target (every frame for smooth motion)
    const smoothing = cameraState.smoothing;
    cameraState.currentCenterX += (cameraState.targetCenterX - cameraState.currentCenterX) * smoothing;
    cameraState.currentCenterY += (cameraState.targetCenterY - cameraState.currentCenterY) * smoothing;
    cameraState.currentExtent += (cameraState.targetExtent - cameraState.currentExtent) * smoothing;
    
    // Apply to params
    params.viewCenter = [cameraState.currentCenterX, cameraState.currentCenterY];
    params.viewExtent = cameraState.currentExtent;
}

function resetCameraToSpawn() {
    // Reset camera to spawn center
    const spawnCenter = params.spawnCenter || [0, 0];
    cameraState.currentCenterX = spawnCenter[0];
    cameraState.currentCenterY = spawnCenter[1];
    cameraState.targetCenterX = spawnCenter[0];
    cameraState.targetCenterY = spawnCenter[1];
    cameraState.currentExtent = 50;
    cameraState.targetExtent = 50;
    params.viewCenter = [spawnCenter[0], spawnCenter[1]];
    params.viewExtent = 50;
}

function setupCanvasControls() {
    // In play mode, camera is automatic - no manual controls
    // Prevent default touch/wheel behavior to avoid page scrolling
    canvas.addEventListener('wheel', e => e.preventDefault(), { passive: false });
    canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
}

function startLevel(index) {
    levelSelectEl.classList.add('hidden');
    gameHUDEl.classList.remove('hidden');
    winOverlayEl.classList.remove('visible');
    skillsBarEl.classList.remove('hidden');
    hideSnapshotOverlay();
    
    // Initialize snapshot UI
    resetSnapshotUI();
    
    // Short bottom instructions hint removed as redundant.
    
    gameEngine.startLevel(index);
}

function showLevelSelect() {
    gameEngine.gameState = 'idle';
    params.paused = true;
    levelSelectEl.classList.remove('hidden');
    gameHUDEl.classList.add('hidden');
    winOverlayEl.classList.remove('visible');
    pauseOverlayEl.classList.remove('visible');
    // Short bottom instructions hint removed as redundant.
    skillsBarEl.classList.add('hidden');
    hideSnapshotOverlay();
    hideGallery();
    latestWinData = null;
}

function updateUIForState(state) {
    pauseOverlayEl.classList.toggle('visible', state === 'paused');
}

function updateProgress(ssim, smoothedSSIM, threshold, progress, cellCount, elapsedTime) {
    // Update cell count
    $('#cellCount').textContent = cellCount;
    
    // Format time as M:SS
    const seconds = Math.floor(elapsedTime / 1000);
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    $('#timeDisplay').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
}

function showWinScreen(ssim, elapsedTime, cellCount, levelIndex) {
    const seconds = Math.floor(elapsedTime / 1000);
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    
    $('#winSSIM').textContent = ssim.toFixed(3);
    $('#winTime').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    $('#winCells').textContent = cellCount;
    
    // Get the winning snapshot image
    const bestSnapshot = gameEngine.getBestSnapshot();
    const imageDataURL = bestSnapshot?.imageDataURL || lenia.getReconstructionDataURL();
    
    // Show preview image
    const previewImg = $('#winPreviewImg');
    if (imageDataURL) {
        previewImg.src = imageDataURL;
        previewImg.style.display = 'block';
    } else {
        previewImg.style.display = 'none';
    }
    
    // Add to collection
    const levelName = gameEngine.currentLevel?.name || 'Unknown';
    if (imageDataURL) {
        addToCollection(levelName, ssim, elapsedTime, imageDataURL);
    }
    
    // Store latest win data for gallery back button
    latestWinData = { ssim, elapsedTime, cellCount, levelIndex, imageDataURL };
    
    // Always show Next button - random levels mean there's always more to play
    $('#nextLevelBtn').style.display = 'block';
    
    winOverlayEl.classList.add('visible');
}

// ============================================================
// Snapshot UI Functions
// ============================================================

const snapshotInventoryEl = $('#snapshotInventory'); // may be null; panel removed
const skillsBarEl = $('#skillsBar');
const snapshotOverlayEl = $('#snapshotOverlay');
let wasPausedBeforeSnapshot = false;
const snapshotCanvasEl = $('#snapshotCanvas');
const snapshotCtx = snapshotCanvasEl.getContext('2d');

// Initialize charge indicators for charge-based skills
function initSkillCharges() {
    // Digest (D) currently has 3 charges; could be driven from config later.
    const digestCharges = $('#charges-d');
    if (digestCharges && digestCharges.children.length === 0) {
        const maxCharges = 3;
        for (let i = 0; i < maxCharges; i++) {
            const dot = document.createElement('div');
            dot.className = 'charge-dot available';
            digestCharges.appendChild(dot);
        }
    }
}

function resetSnapshotUI() {
    // Cancel any running animation
    cancelSnapshotAnimation();
        
    // Initialize charges for charge-based skills
    initSkillCharges();
    
    // Ensure all digest charge dots start as available
    const container = $('#charges-d');
    if (container) {
        const dots = Array.from(container.querySelectorAll('.charge-dot'));
        dots.forEach(dot => dot.classList.add('available'));
    }
    
    // Clear stacked snapshots
    const slotsContainer = $('#snapshotSlots');
    if (slotsContainer) {
        slotsContainer.innerHTML = '';
    }
}

function tickSkillCooldowns() {
    if (!gameEngine || !gameEngine.skills) return;
    for (const [key] of gameEngine.skills) {
        const remaining = gameEngine.getSkillCooldownRemaining(key);
        const btn = $(`#skill${key.toUpperCase()}`);
        const cooldownEl = $(`#cooldown${key.toUpperCase()}`);
        if (!btn || !cooldownEl) continue;
        if (remaining > 0) {
            btn.classList.add('on-cooldown');
            const skill = gameEngine.skills.get(key);
            const pct = skill ? (remaining / skill.cooldownMs) * 100 : 0;
            cooldownEl.style.height = pct + '%';
        } else {
            btn.classList.remove('on-cooldown');
            cooldownEl.style.height = '0%';
        }
    }
    const wActive = gameEngine.speedBurstEndAt && Date.now() < gameEngine.speedBurstEndAt;
    const skillW = $('#skillW');
    if (skillW) skillW.classList.toggle('active-burst', wActive);
}

function updateChargeDisplay(chargesRemaining) {
    // Digest skill currently uses 3 charges; this can be generalized per-skill.
    const container = $('#charges-d');
    if (!container) return;
    const dots = Array.from(container.querySelectorAll('.charge-dot'));
    dots.forEach((dot, i) => {
        if (i < chargesRemaining) dot.classList.add('available');
        else dot.classList.remove('available');
    });
}

function addSnapshotToInventory(snapshot, meetsThreshold) {
    const slotsContainer = $('#snapshotSlots');
    if (!slotsContainer || !snapshot.imageDataURL) return;
    const slot = document.createElement('div');
    slot.className = `snapshot-slot filled ${meetsThreshold ? 'winner' : ''}`;
    
    // Determine SSIM color class
    let ssimClass = 'low';
    if (snapshot.ssim >= 0.7) ssimClass = 'high';
    else if (snapshot.ssim >= 0.4) ssimClass = 'medium';
    
    slot.innerHTML = `
        <img class="snapshot-image" src="${snapshot.imageDataURL}" alt="Snapshot">
        <div class="snapshot-info">
            <div class="snapshot-ssim ${ssimClass}">${snapshot.ssim.toFixed(3)}</div>
        </div>
    `;
    slotsContainer.prepend(slot);
}

function showSnapshotOverlay() {
    // Pause game while snapshot overlay is visible
    if (gameEngine) {
        wasPausedBeforeSnapshot = (gameEngine.gameState === 'paused');
        if (gameEngine.gameState === 'playing') {
            gameEngine.pause();
        }
    }
    snapshotOverlayEl.classList.add('visible');
    $('#snapshotResult').classList.remove('visible');
}

function showSnapshotLoading(pixelCount) {
    showSnapshotOverlay();
    $('#snapshotTitle').textContent = 'Digesting...';
    $('#loadingContainer').classList.remove('hidden');
    $('#canvasContainer').classList.add('hidden');
    $('#snapshotResult').classList.remove('visible');
    $('#loadingPixels').textContent = `${pixelCount.toLocaleString()} pixels`;
}

function hideSnapshotOverlay() {
    // Cancel any running animation
    cancelSnapshotAnimation();
    
    snapshotOverlayEl.classList.remove('visible');
    // Reset state for next time
    $('#loadingContainer').classList.remove('hidden');
    $('#canvasContainer').classList.add('hidden');
    const nextMotifBtn = $('#nextMotifBtn');
    if (nextMotifBtn) nextMotifBtn.classList.add('hidden');
    
    // Restore previous pause state
    if (gameEngine) {
        if (gameEngine.gameState === 'paused' && !wasPausedBeforeSnapshot) {
            gameEngine.resume();
        }
    }
}

function showSnapshotResult(ssim, meetsThreshold, chargesLeft) {
    if (chargesLeft === undefined) chargesLeft = gameEngine.getRemainingCharges();
    const resultEl = $('#snapshotResult');
    const ssimEl = $('#snapshotSSIM');
    const messageEl = $('#resultMessage');
    const nextMotifBtn = $('#nextMotifBtn');
    const continueBtn = $('#continueBtn');
    
    // Animate SSIM value rising up to the final score for a more
    // satisfying transition from reconstruction to result.
    const target = ssim;
    const duration = 800;
    const startTime = performance.now();
    
    function animateSSIM(now) {
        const t = Math.min(1, (now - startTime) / duration);
        const value = target * t;
        ssimEl.textContent = value.toFixed(3);
        if (t < 1) {
            requestAnimationFrame(animateSSIM);
        }
    }
    requestAnimationFrame(animateSSIM);
    
    // Set final colors/messages once; SSIM text will drift up into place.
    // Reset buttons visibility
    if (continueBtn) continueBtn.classList.add('hidden');
    if (nextMotifBtn) nextMotifBtn.classList.add('hidden');
    
    if (meetsThreshold) {
        ssimEl.style.color = '#4af2a1';
        messageEl.className = 'result-message success';
        messageEl.textContent = 'Target reached! Level complete!';
        if (nextMotifBtn) nextMotifBtn.classList.remove('hidden');
    } else {
        ssimEl.style.color = ssim >= 0.4 ? '#ffd93d' : '#ff6b6b';
        if (chargesLeft > 0) {
            messageEl.className = 'result-message continue';
            messageEl.textContent = `Keep going! ${chargesLeft} digest${chargesLeft > 1 ? 's' : ''} remaining`;
            // Give the player a calm confirm button instead of auto-hide
            if (continueBtn) continueBtn.classList.remove('hidden');
        } else {
            messageEl.className = 'result-message motif-failed';
            messageEl.textContent = 'Motif failed.';
            if (nextMotifBtn) nextMotifBtn.classList.remove('hidden');
        }
    }
    
    resultEl.classList.add('visible');
}

// Snapshot animation
let animationFrameId = null;
let currentSnapshot = null;

function cancelSnapshotAnimation() {
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    currentSnapshot = null;
}

async function playSnapshotAnimation(snapshot, eatenPixels, reconstruction) {
    cancelSnapshotAnimation();
    currentSnapshot = snapshot;

    $('#snapshotTitle').textContent = 'Reconstructing...';
    $('#loadingContainer').classList.add('hidden');
    $('#canvasContainer').classList.remove('hidden');

    const canvas = snapshotCanvasEl;
    const ctx = snapshotCtx;
    const displayWidth = canvas.width;
    const displayHeight = canvas.height;

    const reconWidth = reconstruction.width || 256;
    const reconHeight = reconstruction.height || 256;
    const totalPixels = reconWidth * reconHeight;

    if (!snapshot.imageDataURL) {
        finishSnapshotAnimation(snapshot, reconstruction);
        return;
    }

    // Load final reconstruction image to get pixel data
    const img = new Image();
    img.onerror = () => {
        finishSnapshotAnimation(snapshot, reconstruction);
    };
    img.onload = () => {
        const srcCanvas = document.createElement('canvas');
        srcCanvas.width = reconWidth;
        srcCanvas.height = reconHeight;
        const srcCtx = srcCanvas.getContext('2d');
        srcCtx.drawImage(img, 0, 0, reconWidth, reconHeight);
        const sourceData = srcCtx.getImageData(0, 0, reconWidth, reconHeight);
        const src = sourceData.data;

        // Buffer: same resolution, start with random colors (raster form)
        const buffer = new Uint8ClampedArray(reconWidth * reconHeight * 4);
        for (let i = 0; i < buffer.length; i += 4) {
            buffer[i] = Math.floor(Math.random() * 256);
            buffer[i + 1] = Math.floor(Math.random() * 256);
            buffer[i + 2] = Math.floor(Math.random() * 256);
            buffer[i + 3] = 255;
        }

        const bufferImageData = new ImageData(buffer, reconWidth, reconHeight);
        const offscreen = document.createElement('canvas');
        offscreen.width = reconWidth;
        offscreen.height = reconHeight;
        const offCtx = offscreen.getContext('2d');

        const animDuration = 1500;
        const startTime = performance.now();
        let lastFilled = 0;

        function animateFrame(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(1, elapsed / animDuration);
            const nextIndex = Math.min(totalPixels, Math.floor(progress * (totalPixels + 1)));

            // Raster order: copy only new pixels (lastFilled..nextIndex) from source into buffer
            for (let i = lastFilled; i < nextIndex; i++) {
                const idx = i * 4;
                buffer[idx] = src[idx];
                buffer[idx + 1] = src[idx + 1];
                buffer[idx + 2] = src[idx + 2];
                buffer[idx + 3] = 255;
            }
            lastFilled = nextIndex;

            offCtx.putImageData(bufferImageData, 0, 0);

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, displayWidth, displayHeight);
            const scale = Math.min(displayWidth / reconWidth, displayHeight / reconHeight) * 0.9;
            const dx = (displayWidth - reconWidth * scale) / 2;
            const dy = (displayHeight - reconHeight * scale) / 2;
            ctx.drawImage(offscreen, 0, 0, reconWidth, reconHeight, dx, dy, reconWidth * scale, reconHeight * scale);

            if (progress < 1) {
                animationFrameId = requestAnimationFrame(animateFrame);
            } else {
                finishSnapshotAnimation(snapshot, reconstruction);
            }
        }

        animationFrameId = requestAnimationFrame(animateFrame);
    };
    img.src = snapshot.imageDataURL;
}

function finishSnapshotAnimation(snapshot, reconstruction) {
    const canvas = snapshotCanvasEl;
    const ctx = snapshotCtx;
    
    const completeWithResult = () => {
        // Complete digest first so charge count is correct when we show the result
        gameEngine.completeDigest(snapshot);
        const meetsThreshold = snapshot.ssim >= gameEngine.winCondition.threshold;
        const chargesLeft = gameEngine.getRemainingCharges();
        
        showSnapshotResult(snapshot.ssim, meetsThreshold, chargesLeft);
        
        if (meetsThreshold) {
            // For wins, keep the reconstruction overlay visible so the
            // player can enjoy the result and advance via the button.
        } else if (chargesLeft === 0) {
            // Motif failed: wait for user to click "Next motif ‚Üí" (no auto-advance)
        } else {
            // Non-winning digest with charges left: wait for player to press "Back to level".
        }
    };
    
    // Draw final reconstruction image
    if (snapshot.imageDataURL) {
        const img = new Image();
        img.onload = () => {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Center the image
            const scale = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.9;
            const x = (canvas.width - img.width * scale) / 2;
            const y = (canvas.height - img.height * scale) / 2;
            ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
            
            completeWithResult();
        };
        img.onerror = () => {
            console.warn('[Snapshot] Failed to load image, showing result anyway');
            completeWithResult();
        };
        img.src = snapshot.imageDataURL;
    } else {
        // No image URL, just show the result
        console.warn('[Snapshot] No image data URL available');
        completeWithResult();
    }
}

// Eaten pixels rings: throttle updates (getEatenPixels reads from GPU)
let eatenRingsFrameCount = 0;
const EATEN_RINGS_THROTTLE = 15;

function updateEatenRings() {
    const canvasEl = $('#eatenRingsCanvas');
    if (!canvasEl || !lenia || typeof lenia.getEatenPixels !== 'function') return;
    const ctx = canvasEl.getContext('2d');
    if (!ctx) return;
    const width = canvasEl.width;
    const height = canvasEl.height;
    const d = Math.min(width, height);
    const cx = width / 2;
    const cy = height / 2;
    const margin = 6;
    const maxRadius = d / 2 - margin;

    // Get current eaten pixels, excluding digested pixels so that
    // digesting clears the accumulation.
    const excludeKeys = (typeof gameEngine !== 'undefined' && gameEngine && gameEngine.digestedPixelKeys)
        ? gameEngine.digestedPixelKeys
        : null;
    const eaten = lenia.getEatenPixels(true, excludeKeys);
    const totalImagePixels = lenia.originalResourceData
            ? lenia.originalResourceData.length / 4
            : (lenia.resourceTexSize || 512) ** 2;

    ctx.clearRect(0, 0, width, height);
    if (!eaten || eaten.length === 0) return;

    const n = eaten.length;
    
    // Update numeric eaten pixels counter in HUD
    const eatenCountEl = $('#eatenPixelsCount');
    if (eatenCountEl) {
        eatenCountEl.textContent = n.toLocaleString();
    }

    // Overall coverage (0‚Äì1)
    const coverage = Math.min(1, n / totalImagePixels);
    // Ease coverage so early growth is more visible (same feel as before).
    const eased = Math.pow(coverage, 0.4);
    const filledRadius = Math.max(0, eased * maxRadius);

    // Use many thin rings, but drive their count by eased coverage so
    // early rings appear quickly and later ones fill in more slowly.
    const maxRings = 36;
    let ringCount = Math.floor(eased * maxRings);
    ringCount = Math.max(1, Math.min(maxRings, ringCount || 1));
    const perRing = Math.max(1, Math.floor(n / ringCount));

    // Draw from inner to outer so new rings appear at the edge while
    // keeping earlier inner structure visible.
    for (let ring = 0; ring < ringCount; ring++) {
        const startIdx = ring * perRing;
        const endIdx = (ring === ringCount - 1) ? n : Math.min(n, (ring + 1) * perRing);
        if (startIdx >= endIdx) continue;

        let sumR = 0, sumG = 0, sumB = 0;
        let count = 0;
        for (let i = startIdx; i < endIdx; i++) {
            const p = eaten[i];
            sumR += p.r != null ? p.r : 0;
            sumG += p.g != null ? p.g : 0;
            sumB += p.b != null ? p.b : 0;
            count++;
        }
        if (count === 0) continue;
        const avgR = Math.round((sumR / count) * 255);
        const avgG = Math.round((sumG / count) * 255);
        const avgB = Math.round((sumB / count) * 255);

        // Rings grow from center outward as coverage increases.
        // Outer radius of last ring = filledRadius.
        const innerT = ring / ringCount;
        const outerT = (ring + 1) / ringCount;
        const innerRadius = innerT * filledRadius;
        const outerRadius = outerT * filledRadius;

        ctx.fillStyle = `rgb(${avgR},${avgG},${avgB})`;
        ctx.beginPath();
        ctx.arc(cx, cy, outerRadius, 0, Math.PI * 2);
        ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();
    }
}

// Animation loop
let lastFrameTime = 0;

function animate(currentTime) {
    requestAnimationFrame(animate);
    
    // FPS limiting
    const targetInterval = 1000 / params.targetFPS;
    if (currentTime - lastFrameTime < targetInterval) {
        return;
    }
    lastFrameTime = currentTime;
    
    // Resize canvas
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    if (canvas.width < 768) {
        canvas.width = canvas.clientWidth * window.devicePixelRatio;
        canvas.height = canvas.clientHeight * window.devicePixelRatio;
    }
    
    // Skip simulation when paused or not actively playing
    // Use isSimulationActive() which returns true only when gameState === 'playing'
    if (params.paused || !gameEngine.isSimulationActive()) {
        // Still render current state
        if (lenia) {
            const touchRadius = params.touchRadius * params.viewExtent;
            const renderArgs = {
                touchPos: params.mousePos,
                touchRadius,
                viewCenter: params.viewCenter,
                viewExtent: params.viewExtent
            };
            
            if (params.renderMode === 3) {
                lenia.renderCompressedReconstruction(null, renderArgs);
            } else {
                lenia.render(null, renderArgs);
                if (params.showTrailsOverlay) {
                    lenia.renderTrailsOverlay(null, renderArgs);
                }
            }
        }
        return;
    }
    
    // Simulation step
    const touchRadius = params.touchRadius * params.viewExtent;
    const renderArgs = {
        touchPos: params.mousePos,
        touchRadius,
        viewCenter: params.viewCenter,
        viewExtent: params.viewExtent
    };
    
    // Step simulation
    for (let i = 0; i < params.stepN; i++) {
        lenia.step({
            attractPos: params.mousePos,
            attractRadius: 0,
            stepN: 1
        });
    }
    
    // Consume resources
    if (params.consumeEnabled) {
        lenia.consumeResources();
    }
    
    // Life cycle
    if (params.enableLifeCycle) {
        if (params.enableDeaths) {
            lenia.processDeaths();
        }
        // Automatic reproduction has been removed for game mode.
        // Reproduction is now triggered explicitly via the Q \"split\" skill,
        // which calls into cpuReproductionStep/processReproduction directly.
    }
    
    // Accumulate trails
    lenia.accumulateTrails();
    
    // Update auto-camera to follow particles
    updateAutoCamera();
    
    // Update renderArgs with new camera position
    renderArgs.viewCenter = params.viewCenter;
    renderArgs.viewExtent = params.viewExtent;
    
    // NOTE: Reconstruction is now ONLY calculated when K is pressed for snapshot
    // This significantly improves performance by not constantly running the expensive
    // reconstruction calculation in the background
    
    // Render based on current mode
    if (params.renderMode === 3) {
        lenia.renderCompressedReconstruction(null, renderArgs);
    } else {
        lenia.render(null, renderArgs);
        if (params.showTrailsOverlay) {
            lenia.renderTrailsOverlay(null, renderArgs);
        }
    }
    
    // Update game engine (speed burst, win condition) and skill cooldown UI
    gameEngine.update();
    tickSkillCooldowns();
    // Eaten pixels rings (throttled, only when playing)
    if (gameEngine.isPlayMode() && lenia) {
        eatenRingsFrameCount++;
        if (eatenRingsFrameCount % EATEN_RINGS_THROTTLE === 0) {
            updateEatenRings();
        }
    }
}

// Start the game
initGame();
</script>
</html>
